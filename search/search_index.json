{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"NATS Micro for Python","text":"<p>This is not an official NATS project</p> <p>This is a personal project and is not endorsed by the NATS.io community. It is not guaranteed to be maintained or supported.</p> <p>This is an experimental project</p> <p>This project is a prototype and should not be used for anything serious. It is not tested, nor is it guaranteed to be correct.</p> <p>The micro package in the NATS.go library provides a simple way to create microservices that leverage NATS for scalability, load management and observability.</p> <p>This project is an attempt to implement the same API in Python.</p>"},{"location":"#references","title":"References","text":"<ul> <li> <p>The reference document for NATS Micro is the ADR-32: Service API.</p> </li> <li> <p>The reference implementation is the Go micro package.</p> </li> <li> <p>A typescript implementation is available in nats.deno</p> </li> </ul>"},{"location":"#why-does-this-exist","title":"Why does this exist ?","text":"<ul> <li> <p>I wanted to give a try to implementing the ADR-32 in Python.</p> </li> <li> <p>Maybe this can help getting an official implementation in the NATS Python client.</p> </li> </ul>"},{"location":"#whats-lacking","title":"What's lacking ?","text":"<ul> <li>There is no test, and it may not be correct.</li> </ul>"},{"location":"#how-to-install","title":"How to install","text":"pip install git+https://github.com/charbonats/nats-micro.git"},{"location":"#api-proposal","title":"API Proposal","text":"<p>The API is inspired by the Go micro package:</p> <ul> <li>In order to use the package, you need to create a NATS connection using the nats-py package:</li> </ul> <pre><code>from nats.aio.client import Client\n\n# Somewhere in an async function\nnc = await Client().connect(\"nats://localhost:4222\")\n</code></pre> <ul> <li>Create a new service with <code>micro.add_service</code>:</li> </ul> <pre><code>from nats_contrib import micro\n\n\nservice = micro.add_service(\n    nc,\n    name=\"demo-service\",\n    version=\"1.0.0\",\n    description=\"Demo service\",\n)\n</code></pre> <ul> <li>Unlike the Go implementation, the service is not started automatically. You need to call <code>service.start</code> to start the service, or use the service as an async context manager which allows to both create and start the service in a single line:</li> </ul> <pre><code>async with micro.add_service(\n    nc,\n    name=\"demo-service\",\n    version=\"1.0.0\",\n    description=\"Demo service\",\n) as service:\n    ...\n</code></pre> <ul> <li>Once service is started, you can add endpoints to the service using <code>Service.add_endpoint</code>:</li> </ul> <pre><code>async def echo(req: micro.Request) -&gt; None:\n    \"\"\"Echo the request data back to the client.\"\"\"\n    await req.respond(req.data())\n\n\nawait service.add_endpoint(\n    name=\"echo\",\n    handler=echo,\n)\n</code></pre> <p>As defined in the ADR, an endpoint must provide at least a name and a handler. The handler is a coroutine that takes a <code>micro.Request</code> as its only argument and returns <code>None</code>.</p> <p>If no subject is provided, the endpoint will use the service name as the subject. It's possible to provide a subject with the <code>subject</code> argument:</p> <pre><code>await service.add_endpoint(\n    name=\"echo\",\n    handler=echo,\n    subject=\"ECHO\",\n)\n</code></pre> <ul> <li>You can also add groups to the service:</li> </ul> <pre><code>group = service.add_group(\"demo\")\n</code></pre> <p>As defined in the ADR, a group serves as a common prefix to all endpoints registered in it.</p> <ul> <li>You can add endpoints to a group using <code>Group.add_endpoint</code></li> </ul> <pre><code>await group.add_endpoint(\n    name=\"echo\",\n    handler=echo,\n)\n</code></pre> <p>This is equivalent to adding an endpoint to the service with the subject prefixed by the group name.</p> <ul> <li>Once you're done, you can stop the service with <code>service.stop()</code> if it was not used as an async context manager:</li> </ul> <pre><code>await service.stop()\n</code></pre> <ul> <li>You can check if the stop() method was called with <code>service.stopped</code>:</li> </ul> <pre><code>assert service.stopped\n</code></pre>"},{"location":"#example-usage","title":"Example usage","text":"<p>This example shows how to create a simple service that echoes the request data back to the client and to run it until the application receives a SIGINT or a SIGTERM signal.</p> examples/minimal.py<pre><code>from nats_contrib import micro\n\n\nasync def echo(req: micro.Request) -&gt; None:\n    \"\"\"Echo the request data back to the client.\"\"\"\n    await req.respond(req.data())\n\n\nasync def setup(ctx: micro.sdk.Context) -&gt; None:\n    \"\"\"Configure the service.\n\n    This function is executed after the NATS connection is established.\n    \"\"\"\n    # Connect to NATS and close it when the context is closed\n    # micro.add_service returns an AsyncContextManager that will\n    # start the service when entered and stop it when exited.\n    service = await ctx.add_service(\n        name=\"demo-service\",\n        version=\"1.0.0\",\n        description=\"Demo service\",\n    )\n    # A group is a collection of endpoints with\n    # the same subject prefix.\n    group = service.add_group(\"demo\")\n    # Add an endpoint to the service\n    await group.add_endpoint(\n        name=\"echo\",\n        subject=\"ECHO\",\n        handler=echo,\n    )\n</code></pre> <p>After you've cloned the repo and install the project, you can run the example above with the help of the <code>micro</code> CLI tool:</p> micro run examples/minimal.py <p>Once the service is running, you can use the <code>micro</code> CLI tool to send a request to the <code>demo.ECHO</code> subject:</p> micro request demo.ECHO \"Hello, world!\"Hello, World! <p>You should receive the same message back from the service.</p> <p>You can also use the <code>micro</code> CLI tool to discover the service:</p> micro ping[  {    \"name\": \"demo-service\",    \"id\": \"c9538e45b3739a339a217d26f3bcb376\",    \"version\": \"1.0.0\",    \"metadata\": {},    \"type\": \"io.nats.micro.v1.ping_response\"  }] <p>You can also use the <code>micro</code> CLI tool to request service stats:</p> micro info demo-service[  {    \"name\": \"demo-service\",    \"id\": \"c9538e45b3739a339a217d26f3bcb376\",    \"version\": \"1.0.0\",    \"description\": \"Demo service\",    \"metadata\": {},    \"endpoints\": [      {        \"name\": \"echo\",        \"subject\": \"demo.ECHO\",        \"metadata\": {},        \"queue_group\": \"q\"      }    ],    \"type\": \"io.nats.micro.v1.info_response\"  }] <p>You can also use the <code>micro</code> CLI tool to request service stats:</p> micro stats demo-service[  {    \"name\": \"demo-service\",    \"id\": \"c9538e45b3739a339a217d26f3bcb376\",    \"version\": \"1.0.0\",    \"started\": \"2024-02-27T00:01:31.555469Z\",    \"endpoints\": [      {        \"name\": \"echo\",        \"subject\": \"demo.ECHO\",        \"num_requests\": 4,        \"num_errors\": 0,        \"last_error\": \"\",        \"processing_time\": 875900,        \"average_processing_time\": 218975,        \"queue_group\": \"q\",        \"data\": {}      }    ],    \"metadata\": {},    \"type\": \"io.nats.micro.v1.stats_response\"  }]"},{"location":"#other-works","title":"Other works","text":"<ul> <li> <p>NATS Request Many</p> </li> <li> <p>NATS Connect Opts</p> </li> </ul>"},{"location":"LICENSE/","title":"License","text":"<p>MIT License</p> <p>Copyright (c) 2024 Guillaume Charbonnier</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"SUMMARY/","title":"SUMMARY","text":"<ul> <li>Home</li> <li>Reference</li> <li>Coverage</li> <li>License</li> </ul>"},{"location":"reference/nats_contrib/micro/","title":"Reference","text":""},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.Handler","title":"<code>Handler: TypeAlias = Callable[['Request'], Awaitable[None]]</code>  <code>module-attribute</code>","text":"<p>Handler is a function that processes a micro request.</p>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.Client","title":"<code>Client</code>","text":"Source code in <code>src/nats_contrib/micro/client.py</code> <pre><code>class Client:\n\n    def __init__(\n        self,\n        nc: NATS,\n        default_max_wait: float = 0.5,\n        api_prefix: str = API_PREFIX,\n    ) -&gt; None:\n        self.nc = nc\n        self.api_prefix = api_prefix\n        self.request_executor = RequestManyExecutor(nc, default_max_wait)\n\n    async def request(\n        self,\n        subject: str,\n        data: bytes | None = None,\n        headers: dict[str, str] | None = None,\n        timeout: float = 1,\n    ) -&gt; Msg:\n        \"\"\"Send a request and get the response.\n\n        This method should be prefered over using the NATS client directly\n        because it will handle the service errors properly.\n\n        Args:\n            subject: The subject to send the request to.\n            data: The request data.\n            headers: Additional request headers.\n            timeout: The maximum time to wait for a response.\n\n        Returns:\n\n        \"\"\"\n        response = await self.nc.request(\n            subject, data or b\"\", headers=headers, timeout=timeout\n        )\n        if response.headers:\n            error_code = response.headers.get(\"Nats-Service-Error-Code\")\n            if error_code:\n                raise ServiceError(\n                    int(error_code),\n                    response.headers.get(\"Nats-Service-Error\", \"\"),\n                    subject=subject,\n                    data=response.data,\n                    headers=response.headers or {},\n                )\n\n        return response\n\n    async def ping(\n        self,\n        service: str | None = None,\n        max_wait: float | None = None,\n        max_count: int | None = None,\n        max_interval: float | None = None,\n    ) -&gt; list[PingInfo]:\n        \"\"\"Ping all the services.\"\"\"\n        subject = internal.get_internal_subject(\n            internal.ServiceVerb.PING, service, None, self.api_prefix\n        )\n        responses = await self.request_executor(\n            subject,\n            max_count=max_count,\n            max_wait=max_wait,\n            max_interval=max_interval,\n        )\n        return [PingInfo.from_response(json.loads(res.data)) for res in responses]\n\n    async def info(\n        self,\n        service: str | None = None,\n        max_wait: float | None = None,\n        max_count: int | None = None,\n        max_interval: float | None = None,\n    ) -&gt; list[ServiceInfo]:\n        \"\"\"Get all service informations.\"\"\"\n        subject = internal.get_internal_subject(\n            internal.ServiceVerb.INFO, service, None, self.api_prefix\n        )\n        responses = await self.request_executor(\n            subject,\n            max_count=max_count,\n            max_wait=max_wait,\n            max_interval=max_interval,\n        )\n        return [ServiceInfo.from_response(json.loads(res.data)) for res in responses]\n\n    async def stats(\n        self,\n        service: str | None = None,\n        max_wait: float | None = None,\n        max_count: int | None = None,\n        max_interval: float | None = None,\n    ) -&gt; list[ServiceStats]:\n        \"\"\"Get all services stats.\"\"\"\n        subject = internal.get_internal_subject(\n            internal.ServiceVerb.STATS, service, None, self.api_prefix\n        )\n        responses = await self.request_executor(\n            subject,\n            max_count=max_count,\n            max_wait=max_wait,\n            max_interval=max_interval,\n        )\n        return [ServiceStats.from_response(json.loads(res.data)) for res in responses]\n\n    def ping_iter(\n        self,\n        service: str | None = None,\n        max_wait: float | None = None,\n        max_count: int | None = None,\n        max_interval: float | None = None,\n    ) -&gt; AsyncContextManager[AsyncIterator[PingInfo]]:\n        \"\"\"Ping all the services.\"\"\"\n        subject = internal.get_internal_subject(\n            internal.ServiceVerb.PING, service, None, self.api_prefix\n        )\n        return transform(\n            RequestManyIterator(\n                self.nc,\n                subject,\n                inbox=self.nc.new_inbox(),\n                max_count=max_count,\n                max_wait=max_wait,\n                max_interval=max_interval,\n            ),\n            lambda res: PingInfo.from_response(json.loads(res.data)),\n        )\n\n    def info_iter(\n        self,\n        service: str | None = None,\n        max_wait: float | None = None,\n        max_count: int | None = None,\n        max_interval: float | None = None,\n    ) -&gt; AsyncContextManager[AsyncIterator[ServiceInfo]]:\n        \"\"\"Get all service informations.\"\"\"\n        subject = internal.get_internal_subject(\n            internal.ServiceVerb.INFO, service, None, self.api_prefix\n        )\n        return transform(\n            RequestManyIterator(\n                self.nc,\n                subject,\n                inbox=self.nc.new_inbox(),\n                max_count=max_count,\n                max_wait=max_wait,\n                max_interval=max_interval,\n            ),\n            lambda res: ServiceInfo.from_response(json.loads(res.data)),\n        )\n\n    def stats_iter(\n        self,\n        service: str | None = None,\n        max_wait: float | None = None,\n        max_count: int | None = None,\n        max_interval: float | None = None,\n    ) -&gt; AsyncContextManager[AsyncIterator[ServiceStats]]:\n        \"\"\"Get all services stats.\"\"\"\n        subject = internal.get_internal_subject(\n            internal.ServiceVerb.STATS, service, None, self.api_prefix\n        )\n        return transform(\n            RequestManyIterator(\n                self.nc,\n                subject,\n                inbox=self.nc.new_inbox(),\n                max_count=max_count,\n                max_wait=max_wait,\n                max_interval=max_interval,\n            ),\n            lambda res: ServiceStats.from_response(json.loads(res.data)),\n        )\n\n    def service(self, service: str) -&gt; Service:\n        \"\"\"Get a client for a single service.\"\"\"\n        return Service(self, service)\n\n    def instance(self, service: str, id: str) -&gt; Instance:\n        \"\"\"Get a client for a single service instance.\"\"\"\n        return Instance(self, service, id)\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.Client.info","title":"<code>info(service=None, max_wait=None, max_count=None, max_interval=None)</code>  <code>async</code>","text":"<p>Get all service informations.</p> Source code in <code>src/nats_contrib/micro/client.py</code> <pre><code>async def info(\n    self,\n    service: str | None = None,\n    max_wait: float | None = None,\n    max_count: int | None = None,\n    max_interval: float | None = None,\n) -&gt; list[ServiceInfo]:\n    \"\"\"Get all service informations.\"\"\"\n    subject = internal.get_internal_subject(\n        internal.ServiceVerb.INFO, service, None, self.api_prefix\n    )\n    responses = await self.request_executor(\n        subject,\n        max_count=max_count,\n        max_wait=max_wait,\n        max_interval=max_interval,\n    )\n    return [ServiceInfo.from_response(json.loads(res.data)) for res in responses]\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.Client.info_iter","title":"<code>info_iter(service=None, max_wait=None, max_count=None, max_interval=None)</code>","text":"<p>Get all service informations.</p> Source code in <code>src/nats_contrib/micro/client.py</code> <pre><code>def info_iter(\n    self,\n    service: str | None = None,\n    max_wait: float | None = None,\n    max_count: int | None = None,\n    max_interval: float | None = None,\n) -&gt; AsyncContextManager[AsyncIterator[ServiceInfo]]:\n    \"\"\"Get all service informations.\"\"\"\n    subject = internal.get_internal_subject(\n        internal.ServiceVerb.INFO, service, None, self.api_prefix\n    )\n    return transform(\n        RequestManyIterator(\n            self.nc,\n            subject,\n            inbox=self.nc.new_inbox(),\n            max_count=max_count,\n            max_wait=max_wait,\n            max_interval=max_interval,\n        ),\n        lambda res: ServiceInfo.from_response(json.loads(res.data)),\n    )\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.Client.instance","title":"<code>instance(service, id)</code>","text":"<p>Get a client for a single service instance.</p> Source code in <code>src/nats_contrib/micro/client.py</code> <pre><code>def instance(self, service: str, id: str) -&gt; Instance:\n    \"\"\"Get a client for a single service instance.\"\"\"\n    return Instance(self, service, id)\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.Client.ping","title":"<code>ping(service=None, max_wait=None, max_count=None, max_interval=None)</code>  <code>async</code>","text":"<p>Ping all the services.</p> Source code in <code>src/nats_contrib/micro/client.py</code> <pre><code>async def ping(\n    self,\n    service: str | None = None,\n    max_wait: float | None = None,\n    max_count: int | None = None,\n    max_interval: float | None = None,\n) -&gt; list[PingInfo]:\n    \"\"\"Ping all the services.\"\"\"\n    subject = internal.get_internal_subject(\n        internal.ServiceVerb.PING, service, None, self.api_prefix\n    )\n    responses = await self.request_executor(\n        subject,\n        max_count=max_count,\n        max_wait=max_wait,\n        max_interval=max_interval,\n    )\n    return [PingInfo.from_response(json.loads(res.data)) for res in responses]\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.Client.ping_iter","title":"<code>ping_iter(service=None, max_wait=None, max_count=None, max_interval=None)</code>","text":"<p>Ping all the services.</p> Source code in <code>src/nats_contrib/micro/client.py</code> <pre><code>def ping_iter(\n    self,\n    service: str | None = None,\n    max_wait: float | None = None,\n    max_count: int | None = None,\n    max_interval: float | None = None,\n) -&gt; AsyncContextManager[AsyncIterator[PingInfo]]:\n    \"\"\"Ping all the services.\"\"\"\n    subject = internal.get_internal_subject(\n        internal.ServiceVerb.PING, service, None, self.api_prefix\n    )\n    return transform(\n        RequestManyIterator(\n            self.nc,\n            subject,\n            inbox=self.nc.new_inbox(),\n            max_count=max_count,\n            max_wait=max_wait,\n            max_interval=max_interval,\n        ),\n        lambda res: PingInfo.from_response(json.loads(res.data)),\n    )\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.Client.request","title":"<code>request(subject, data=None, headers=None, timeout=1)</code>  <code>async</code>","text":"<p>Send a request and get the response.</p> <p>This method should be prefered over using the NATS client directly because it will handle the service errors properly.</p> <p>Parameters:</p> Name Type Description Default <code>subject</code> <code>str</code> <p>The subject to send the request to.</p> required <code>data</code> <code>bytes | None</code> <p>The request data.</p> <code>None</code> <code>headers</code> <code>dict[str, str] | None</code> <p>Additional request headers.</p> <code>None</code> <code>timeout</code> <code>float</code> <p>The maximum time to wait for a response.</p> <code>1</code> <p>Returns:</p> Source code in <code>src/nats_contrib/micro/client.py</code> <pre><code>async def request(\n    self,\n    subject: str,\n    data: bytes | None = None,\n    headers: dict[str, str] | None = None,\n    timeout: float = 1,\n) -&gt; Msg:\n    \"\"\"Send a request and get the response.\n\n    This method should be prefered over using the NATS client directly\n    because it will handle the service errors properly.\n\n    Args:\n        subject: The subject to send the request to.\n        data: The request data.\n        headers: Additional request headers.\n        timeout: The maximum time to wait for a response.\n\n    Returns:\n\n    \"\"\"\n    response = await self.nc.request(\n        subject, data or b\"\", headers=headers, timeout=timeout\n    )\n    if response.headers:\n        error_code = response.headers.get(\"Nats-Service-Error-Code\")\n        if error_code:\n            raise ServiceError(\n                int(error_code),\n                response.headers.get(\"Nats-Service-Error\", \"\"),\n                subject=subject,\n                data=response.data,\n                headers=response.headers or {},\n            )\n\n    return response\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.Client.service","title":"<code>service(service)</code>","text":"<p>Get a client for a single service.</p> Source code in <code>src/nats_contrib/micro/client.py</code> <pre><code>def service(self, service: str) -&gt; Service:\n    \"\"\"Get a client for a single service.\"\"\"\n    return Service(self, service)\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.Client.stats","title":"<code>stats(service=None, max_wait=None, max_count=None, max_interval=None)</code>  <code>async</code>","text":"<p>Get all services stats.</p> Source code in <code>src/nats_contrib/micro/client.py</code> <pre><code>async def stats(\n    self,\n    service: str | None = None,\n    max_wait: float | None = None,\n    max_count: int | None = None,\n    max_interval: float | None = None,\n) -&gt; list[ServiceStats]:\n    \"\"\"Get all services stats.\"\"\"\n    subject = internal.get_internal_subject(\n        internal.ServiceVerb.STATS, service, None, self.api_prefix\n    )\n    responses = await self.request_executor(\n        subject,\n        max_count=max_count,\n        max_wait=max_wait,\n        max_interval=max_interval,\n    )\n    return [ServiceStats.from_response(json.loads(res.data)) for res in responses]\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.Client.stats_iter","title":"<code>stats_iter(service=None, max_wait=None, max_count=None, max_interval=None)</code>","text":"<p>Get all services stats.</p> Source code in <code>src/nats_contrib/micro/client.py</code> <pre><code>def stats_iter(\n    self,\n    service: str | None = None,\n    max_wait: float | None = None,\n    max_count: int | None = None,\n    max_interval: float | None = None,\n) -&gt; AsyncContextManager[AsyncIterator[ServiceStats]]:\n    \"\"\"Get all services stats.\"\"\"\n    subject = internal.get_internal_subject(\n        internal.ServiceVerb.STATS, service, None, self.api_prefix\n    )\n    return transform(\n        RequestManyIterator(\n            self.nc,\n            subject,\n            inbox=self.nc.new_inbox(),\n            max_count=max_count,\n            max_wait=max_wait,\n            max_interval=max_interval,\n        ),\n        lambda res: ServiceStats.from_response(json.loads(res.data)),\n    )\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.Context","title":"<code>Context</code>","text":"<p>A class to run micro services easily.</p> <p>This class is useful in a main function to manage ensure that all async resources are cleaned up properly when the program is cancelled.</p> <p>It also allows to listen to signals and cancel the program when a signal is received easily.</p> Source code in <code>src/nats_contrib/micro/context.py</code> <pre><code>class Context:\n    \"\"\"A class to run micro services easily.\n\n    This class is useful in a main function to manage ensure\n    that all async resources are cleaned up properly when the\n    program is cancelled.\n\n    It also allows to listen to signals and cancel the program\n    when a signal is received easily.\n    \"\"\"\n\n    def __init__(self, client: NATS | None = None):\n        self.exit_stack = contextlib.AsyncExitStack()\n        self.cancel_event = asyncio.Event()\n        self.client = client or NATS()\n        self.services: list[Service] = []\n\n    async def connect(self, *options: ConnectOption) -&gt; None:\n        \"\"\"Connect to the NATS server. Does not raise an error when cancelled\"\"\"\n        await self.wait_for(connect(client=self.client, *options))\n        if not self.cancelled():\n            await self.enter(self.client)\n\n    async def add_service(\n        self,\n        name: str,\n        version: str,\n        description: str | None = None,\n        metadata: dict[str, str] | None = None,\n        queue_group: str | None = None,\n        pending_bytes_limit_by_endpoint: int | None = None,\n        pending_msgs_limit_by_endpoint: int | None = None,\n        now: Callable[[], datetime.datetime] | None = None,\n        id_generator: Callable[[], str] | None = None,\n        api_prefix: str | None = None,\n    ) -&gt; Service:\n        \"\"\"Add a service to the context.\n\n        This will start the service using the client used\n        to connect to the NATS server.\n        \"\"\"\n        service = add_service(\n            self.client,\n            name,\n            version,\n            description,\n            metadata,\n            queue_group,\n            pending_bytes_limit_by_endpoint,\n            pending_msgs_limit_by_endpoint,\n            now,\n            id_generator,\n            api_prefix,\n        )\n        await self.enter(service)\n        self.services.append(service)\n        return service\n\n    def reset(self) -&gt; None:\n        \"\"\"Reset all the services.\"\"\"\n        for service in self.services:\n            service.reset()\n\n    def cancel(self) -&gt; None:\n        \"\"\"Set the cancel event.\"\"\"\n        self.cancel_event.set()\n\n    def cancelled(self) -&gt; bool:\n        \"\"\"Check if the context was cancelled.\"\"\"\n        return self.cancel_event.is_set()\n\n    def add_disconnected_callback(\n        self, callback: Callable[[], Awaitable[None]]\n    ) -&gt; None:\n        \"\"\"Add a disconnected callback to the NATS client.\"\"\"\n        existing = self.client._disconnected_cb  # pyright: ignore[reportPrivateUsage]\n        self.client._disconnected_cb = _chain0(  # pyright: ignore[reportPrivateUsage]\n            existing, callback\n        )\n\n    def add_closed_callback(self, callback: Callable[[], Awaitable[None]]) -&gt; None:\n        \"\"\"Add a closed callback to the NATS client.\"\"\"\n        existing = self.client._closed_cb  # pyright: ignore[reportPrivateUsage]\n        self.client._closed_cb = _chain0(  # pyright: ignore[reportPrivateUsage]\n            existing, callback\n        )\n\n    def add_reconnected_callback(self, callback: Callable[[], Awaitable[None]]) -&gt; None:\n        \"\"\"Add a reconnected callback to the NATS client.\"\"\"\n        existing = self.client._reconnected_cb  # pyright: ignore[reportPrivateUsage]\n        self.client._reconnected_cb = _chain0(  # pyright: ignore[reportPrivateUsage]\n            existing, callback\n        )\n\n    def add_error_callback(\n        self, callback: Callable[[Exception], Awaitable[None]]\n    ) -&gt; None:\n        \"\"\"Add an error callback to the NATS client.\"\"\"\n        existing = self.client._error_cb  # pyright: ignore[reportPrivateUsage]\n        self.client._error_cb = _chain1(  # pyright: ignore[reportPrivateUsage]\n            existing, callback\n        )\n\n    def trap_signal(self, *signals: signal.Signals) -&gt; None:\n        \"\"\"Notify the context that a signal has been received.\"\"\"\n        if not signals:\n            signals = (signal.Signals.SIGINT, signal.Signals.SIGTERM)\n        loop = asyncio.get_event_loop()\n        for sig in signals:\n            loop.add_signal_handler(sig, self.cancel)\n\n    def push(self, callback: Callable[[], Awaitable[None] | None]) -&gt; None:\n        \"\"\"Add a callback to the exit stack.\"\"\"\n        if inspect.iscoroutinefunction(callback):\n            self.exit_stack.push_async_callback(callback)\n        else:\n            self.exit_stack.callback(callback)\n\n    async def enter(self, async_context: AsyncContextManager[T]) -&gt; T:\n        \"\"\"Enter an async context.\"\"\"\n        return await self.exit_stack.enter_async_context(async_context)\n\n    async def wait(self) -&gt; None:\n        \"\"\"Wait for the cancel event to be set.\"\"\"\n        await self.cancel_event.wait()\n\n    async def wait_for(self, coro: Coroutine[Any, Any, Any]) -&gt; None:\n        \"\"\"Run a coroutine in the context and cancel it context is cancelled.\n\n        This method does not raise an exception if the coroutine is cancelled.\n        You can use .cancelled() on the context to check if the coroutine was\n        cancelled.\n        \"\"\"\n        await _run_until_first_complete(coro, self.wait())\n\n    async def __aenter__(self) -&gt; \"Context\":\n        await self.exit_stack.__aenter__()\n        return self\n\n    async def __aexit__(self, *args: Any, **kwargs: Any) -&gt; None:\n        try:\n            await self.exit_stack.__aexit__(None, None, None)\n        finally:\n            self.services.clear()\n\n    async def run_forever(\n        self,\n        setup: Callable[[Context], Coroutine[Any, Any, None]],\n        /,\n        *options: ConnectOption,\n        trap_signals: bool | tuple[signal.Signals, ...] = False,\n    ) -&gt; None:\n        \"\"\"Useful in a main function of a program.\n\n        This method will first connect to the NATS server using the provided\n        options. It will then run the setup function and finally enter any\n        additional services provided.\n\n        If trap_signals is True, it will trap SIGINT and SIGTERM signals\n        and cancel the context when one of these signals is received.\n\n        Other signals can be trapped by providing a tuple of signals to\n        trap.\n\n        This method will not raise an exception if the context is cancelled.\n\n        You can use .cancelled() on the context to check if the coroutine was\n        cancelled.\n\n        Warning:\n            The context must not have been used as an async context manager\n            before calling this method.\n\n        Args:\n            setup: A coroutine to setup the program.\n            options: The options to pass to the connect method.\n            trap_signals: If True, trap SIGINT and SIGTERM signals.\n        \"\"\"\n        async with self as ctx:\n            if trap_signals:\n                if trap_signals is True:\n                    trap_signals = (signal.Signals.SIGINT, signal.Signals.SIGTERM)\n                ctx.trap_signal(*trap_signals)\n            await ctx.wait_for(connect(client=ctx.client, *options))\n            if ctx.cancelled():\n                return\n            await ctx.wait_for(setup(ctx))\n            if ctx.cancelled():\n                return\n            await ctx.wait()\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.Context.add_closed_callback","title":"<code>add_closed_callback(callback)</code>","text":"<p>Add a closed callback to the NATS client.</p> Source code in <code>src/nats_contrib/micro/context.py</code> <pre><code>def add_closed_callback(self, callback: Callable[[], Awaitable[None]]) -&gt; None:\n    \"\"\"Add a closed callback to the NATS client.\"\"\"\n    existing = self.client._closed_cb  # pyright: ignore[reportPrivateUsage]\n    self.client._closed_cb = _chain0(  # pyright: ignore[reportPrivateUsage]\n        existing, callback\n    )\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.Context.add_disconnected_callback","title":"<code>add_disconnected_callback(callback)</code>","text":"<p>Add a disconnected callback to the NATS client.</p> Source code in <code>src/nats_contrib/micro/context.py</code> <pre><code>def add_disconnected_callback(\n    self, callback: Callable[[], Awaitable[None]]\n) -&gt; None:\n    \"\"\"Add a disconnected callback to the NATS client.\"\"\"\n    existing = self.client._disconnected_cb  # pyright: ignore[reportPrivateUsage]\n    self.client._disconnected_cb = _chain0(  # pyright: ignore[reportPrivateUsage]\n        existing, callback\n    )\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.Context.add_error_callback","title":"<code>add_error_callback(callback)</code>","text":"<p>Add an error callback to the NATS client.</p> Source code in <code>src/nats_contrib/micro/context.py</code> <pre><code>def add_error_callback(\n    self, callback: Callable[[Exception], Awaitable[None]]\n) -&gt; None:\n    \"\"\"Add an error callback to the NATS client.\"\"\"\n    existing = self.client._error_cb  # pyright: ignore[reportPrivateUsage]\n    self.client._error_cb = _chain1(  # pyright: ignore[reportPrivateUsage]\n        existing, callback\n    )\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.Context.add_reconnected_callback","title":"<code>add_reconnected_callback(callback)</code>","text":"<p>Add a reconnected callback to the NATS client.</p> Source code in <code>src/nats_contrib/micro/context.py</code> <pre><code>def add_reconnected_callback(self, callback: Callable[[], Awaitable[None]]) -&gt; None:\n    \"\"\"Add a reconnected callback to the NATS client.\"\"\"\n    existing = self.client._reconnected_cb  # pyright: ignore[reportPrivateUsage]\n    self.client._reconnected_cb = _chain0(  # pyright: ignore[reportPrivateUsage]\n        existing, callback\n    )\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.Context.add_service","title":"<code>add_service(name, version, description=None, metadata=None, queue_group=None, pending_bytes_limit_by_endpoint=None, pending_msgs_limit_by_endpoint=None, now=None, id_generator=None, api_prefix=None)</code>  <code>async</code>","text":"<p>Add a service to the context.</p> <p>This will start the service using the client used to connect to the NATS server.</p> Source code in <code>src/nats_contrib/micro/context.py</code> <pre><code>async def add_service(\n    self,\n    name: str,\n    version: str,\n    description: str | None = None,\n    metadata: dict[str, str] | None = None,\n    queue_group: str | None = None,\n    pending_bytes_limit_by_endpoint: int | None = None,\n    pending_msgs_limit_by_endpoint: int | None = None,\n    now: Callable[[], datetime.datetime] | None = None,\n    id_generator: Callable[[], str] | None = None,\n    api_prefix: str | None = None,\n) -&gt; Service:\n    \"\"\"Add a service to the context.\n\n    This will start the service using the client used\n    to connect to the NATS server.\n    \"\"\"\n    service = add_service(\n        self.client,\n        name,\n        version,\n        description,\n        metadata,\n        queue_group,\n        pending_bytes_limit_by_endpoint,\n        pending_msgs_limit_by_endpoint,\n        now,\n        id_generator,\n        api_prefix,\n    )\n    await self.enter(service)\n    self.services.append(service)\n    return service\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.Context.cancel","title":"<code>cancel()</code>","text":"<p>Set the cancel event.</p> Source code in <code>src/nats_contrib/micro/context.py</code> <pre><code>def cancel(self) -&gt; None:\n    \"\"\"Set the cancel event.\"\"\"\n    self.cancel_event.set()\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.Context.cancelled","title":"<code>cancelled()</code>","text":"<p>Check if the context was cancelled.</p> Source code in <code>src/nats_contrib/micro/context.py</code> <pre><code>def cancelled(self) -&gt; bool:\n    \"\"\"Check if the context was cancelled.\"\"\"\n    return self.cancel_event.is_set()\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.Context.connect","title":"<code>connect(*options)</code>  <code>async</code>","text":"<p>Connect to the NATS server. Does not raise an error when cancelled</p> Source code in <code>src/nats_contrib/micro/context.py</code> <pre><code>async def connect(self, *options: ConnectOption) -&gt; None:\n    \"\"\"Connect to the NATS server. Does not raise an error when cancelled\"\"\"\n    await self.wait_for(connect(client=self.client, *options))\n    if not self.cancelled():\n        await self.enter(self.client)\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.Context.enter","title":"<code>enter(async_context)</code>  <code>async</code>","text":"<p>Enter an async context.</p> Source code in <code>src/nats_contrib/micro/context.py</code> <pre><code>async def enter(self, async_context: AsyncContextManager[T]) -&gt; T:\n    \"\"\"Enter an async context.\"\"\"\n    return await self.exit_stack.enter_async_context(async_context)\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.Context.push","title":"<code>push(callback)</code>","text":"<p>Add a callback to the exit stack.</p> Source code in <code>src/nats_contrib/micro/context.py</code> <pre><code>def push(self, callback: Callable[[], Awaitable[None] | None]) -&gt; None:\n    \"\"\"Add a callback to the exit stack.\"\"\"\n    if inspect.iscoroutinefunction(callback):\n        self.exit_stack.push_async_callback(callback)\n    else:\n        self.exit_stack.callback(callback)\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.Context.reset","title":"<code>reset()</code>","text":"<p>Reset all the services.</p> Source code in <code>src/nats_contrib/micro/context.py</code> <pre><code>def reset(self) -&gt; None:\n    \"\"\"Reset all the services.\"\"\"\n    for service in self.services:\n        service.reset()\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.Context.run_forever","title":"<code>run_forever(setup, /, *options, trap_signals=False)</code>  <code>async</code>","text":"<p>Useful in a main function of a program.</p> <p>This method will first connect to the NATS server using the provided options. It will then run the setup function and finally enter any additional services provided.</p> <p>If trap_signals is True, it will trap SIGINT and SIGTERM signals and cancel the context when one of these signals is received.</p> <p>Other signals can be trapped by providing a tuple of signals to trap.</p> <p>This method will not raise an exception if the context is cancelled.</p> <p>You can use .cancelled() on the context to check if the coroutine was cancelled.</p> Warning <p>The context must not have been used as an async context manager before calling this method.</p> <p>Parameters:</p> Name Type Description Default <code>setup</code> <code>Callable[[Context], Coroutine[Any, Any, None]]</code> <p>A coroutine to setup the program.</p> required <code>options</code> <code>ConnectOption</code> <p>The options to pass to the connect method.</p> <code>()</code> <code>trap_signals</code> <code>bool | tuple[Signals, ...]</code> <p>If True, trap SIGINT and SIGTERM signals.</p> <code>False</code> Source code in <code>src/nats_contrib/micro/context.py</code> <pre><code>async def run_forever(\n    self,\n    setup: Callable[[Context], Coroutine[Any, Any, None]],\n    /,\n    *options: ConnectOption,\n    trap_signals: bool | tuple[signal.Signals, ...] = False,\n) -&gt; None:\n    \"\"\"Useful in a main function of a program.\n\n    This method will first connect to the NATS server using the provided\n    options. It will then run the setup function and finally enter any\n    additional services provided.\n\n    If trap_signals is True, it will trap SIGINT and SIGTERM signals\n    and cancel the context when one of these signals is received.\n\n    Other signals can be trapped by providing a tuple of signals to\n    trap.\n\n    This method will not raise an exception if the context is cancelled.\n\n    You can use .cancelled() on the context to check if the coroutine was\n    cancelled.\n\n    Warning:\n        The context must not have been used as an async context manager\n        before calling this method.\n\n    Args:\n        setup: A coroutine to setup the program.\n        options: The options to pass to the connect method.\n        trap_signals: If True, trap SIGINT and SIGTERM signals.\n    \"\"\"\n    async with self as ctx:\n        if trap_signals:\n            if trap_signals is True:\n                trap_signals = (signal.Signals.SIGINT, signal.Signals.SIGTERM)\n            ctx.trap_signal(*trap_signals)\n        await ctx.wait_for(connect(client=ctx.client, *options))\n        if ctx.cancelled():\n            return\n        await ctx.wait_for(setup(ctx))\n        if ctx.cancelled():\n            return\n        await ctx.wait()\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.Context.trap_signal","title":"<code>trap_signal(*signals)</code>","text":"<p>Notify the context that a signal has been received.</p> Source code in <code>src/nats_contrib/micro/context.py</code> <pre><code>def trap_signal(self, *signals: signal.Signals) -&gt; None:\n    \"\"\"Notify the context that a signal has been received.\"\"\"\n    if not signals:\n        signals = (signal.Signals.SIGINT, signal.Signals.SIGTERM)\n    loop = asyncio.get_event_loop()\n    for sig in signals:\n        loop.add_signal_handler(sig, self.cancel)\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.Context.wait","title":"<code>wait()</code>  <code>async</code>","text":"<p>Wait for the cancel event to be set.</p> Source code in <code>src/nats_contrib/micro/context.py</code> <pre><code>async def wait(self) -&gt; None:\n    \"\"\"Wait for the cancel event to be set.\"\"\"\n    await self.cancel_event.wait()\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.Context.wait_for","title":"<code>wait_for(coro)</code>  <code>async</code>","text":"<p>Run a coroutine in the context and cancel it context is cancelled.</p> <p>This method does not raise an exception if the coroutine is cancelled. You can use .cancelled() on the context to check if the coroutine was cancelled.</p> Source code in <code>src/nats_contrib/micro/context.py</code> <pre><code>async def wait_for(self, coro: Coroutine[Any, Any, Any]) -&gt; None:\n    \"\"\"Run a coroutine in the context and cancel it context is cancelled.\n\n    This method does not raise an exception if the coroutine is cancelled.\n    You can use .cancelled() on the context to check if the coroutine was\n    cancelled.\n    \"\"\"\n    await _run_until_first_complete(coro, self.wait())\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.Endpoint","title":"<code>Endpoint</code>","text":"<p>Endpoint manages a service endpoint.</p> Source code in <code>src/nats_contrib/micro/api.py</code> <pre><code>class Endpoint:\n    \"\"\"Endpoint manages a service endpoint.\"\"\"\n\n    def __init__(self, config: internal.EndpointConfig) -&gt; None:\n        self.config = config\n        self.stats = internal.create_endpoint_stats(config)\n        self.info = internal.create_endpoint_info(config)\n        self._sub: Subscription | None = None\n\n    def reset(self) -&gt; None:\n        \"\"\"Reset the endpoint statistics.\"\"\"\n        self.stats = internal.create_endpoint_stats(self.config)\n        self.info = internal.create_endpoint_info(self.config)\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.Endpoint.reset","title":"<code>reset()</code>","text":"<p>Reset the endpoint statistics.</p> Source code in <code>src/nats_contrib/micro/api.py</code> <pre><code>def reset(self) -&gt; None:\n    \"\"\"Reset the endpoint statistics.\"\"\"\n    self.stats = internal.create_endpoint_stats(self.config)\n    self.info = internal.create_endpoint_info(self.config)\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.EndpointInfo","title":"<code>EndpointInfo</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Base</code></p> <p>The information of an endpoint.</p> Source code in <code>src/nats_contrib/micro/models.py</code> <pre><code>@dataclass\nclass EndpointInfo(Base):\n    \"\"\"The information of an endpoint.\"\"\"\n\n    name: str\n    \"\"\"\n    The endopoint name\n    \"\"\"\n    subject: str\n    \"\"\"\n    The subject the endpoint listens on\n    \"\"\"\n    metadata: dict[str, str] | None = None\n    \"\"\"\n    The endpoint metadata.\n    \"\"\"\n    queue_group: str | None = None\n    \"\"\"\n    The queue group this endpoint listens on for requests\n    \"\"\"\n\n    def copy(self) -&gt; EndpointInfo:\n        return replace(\n            self,\n            metadata=None if self.metadata is None else self.metadata.copy(),\n        )\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.EndpointInfo.metadata","title":"<code>metadata: dict[str, str] | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The endpoint metadata.</p>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.EndpointInfo.name","title":"<code>name: str</code>  <code>instance-attribute</code>","text":"<p>The endopoint name</p>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.EndpointInfo.queue_group","title":"<code>queue_group: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The queue group this endpoint listens on for requests</p>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.EndpointInfo.subject","title":"<code>subject: str</code>  <code>instance-attribute</code>","text":"<p>The subject the endpoint listens on</p>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.EndpointStats","title":"<code>EndpointStats</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Base</code></p> <p>Statistics about a specific service endpoint</p> Source code in <code>src/nats_contrib/micro/models.py</code> <pre><code>@dataclass\nclass EndpointStats(Base):\n    \"\"\"\n    Statistics about a specific service endpoint\n    \"\"\"\n\n    name: str\n    \"\"\"\n    The endpoint name\n    \"\"\"\n    subject: str\n    \"\"\"\n    The subject the endpoint listens on\n    \"\"\"\n    num_requests: int\n    \"\"\"\n    The number of requests this endpoint received\n    \"\"\"\n    num_errors: int\n    \"\"\"\n    The number of errors this endpoint encountered\n    \"\"\"\n    last_error: str\n    \"\"\"\n    The last error the service encountered\n    \"\"\"\n    processing_time: int\n    \"\"\"\n    How long, in total, was spent processing requests in the handler\n    \"\"\"\n    average_processing_time: int\n    \"\"\"\n    The average time spent processing requests\n    \"\"\"\n    queue_group: str | None = None\n    \"\"\"\n    The queue group this endpoint listens on for requests\n    \"\"\"\n    data: dict[str, object] | None = None\n    \"\"\"\n    Additional statistics the endpoint makes available\n    \"\"\"\n\n    def copy(self) -&gt; EndpointStats:\n        return replace(self, data=None if self.data is None else self.data.copy())\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.EndpointStats.average_processing_time","title":"<code>average_processing_time: int</code>  <code>instance-attribute</code>","text":"<p>The average time spent processing requests</p>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.EndpointStats.data","title":"<code>data: dict[str, object] | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Additional statistics the endpoint makes available</p>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.EndpointStats.last_error","title":"<code>last_error: str</code>  <code>instance-attribute</code>","text":"<p>The last error the service encountered</p>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.EndpointStats.name","title":"<code>name: str</code>  <code>instance-attribute</code>","text":"<p>The endpoint name</p>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.EndpointStats.num_errors","title":"<code>num_errors: int</code>  <code>instance-attribute</code>","text":"<p>The number of errors this endpoint encountered</p>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.EndpointStats.num_requests","title":"<code>num_requests: int</code>  <code>instance-attribute</code>","text":"<p>The number of requests this endpoint received</p>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.EndpointStats.processing_time","title":"<code>processing_time: int</code>  <code>instance-attribute</code>","text":"<p>How long, in total, was spent processing requests in the handler</p>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.EndpointStats.queue_group","title":"<code>queue_group: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The queue group this endpoint listens on for requests</p>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.EndpointStats.subject","title":"<code>subject: str</code>  <code>instance-attribute</code>","text":"<p>The subject the endpoint listens on</p>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.Group","title":"<code>Group</code>","text":"<p>Group allows for grouping endpoints on a service.</p> <p>Endpoints created using <code>Group.add_endpoint</code> will be grouped under common prefix (group name). New groups can also be derived from a group using <code>Group.add_group</code>.</p> Source code in <code>src/nats_contrib/micro/api.py</code> <pre><code>class Group:\n    \"\"\"Group allows for grouping endpoints on a service.\n\n    Endpoints created using `Group.add_endpoint` will be grouped\n    under common prefix (group name). New groups can also be derived\n    from a group using `Group.add_group`.\n    \"\"\"\n\n    def __init__(self, config: internal.GroupConfig, service: Service) -&gt; None:\n        self._config = config\n        self._service = service\n\n    def add_group(\n        self,\n        name: str,\n        queue_group: str | None = None,\n        pending_bytes_limit_by_endpoint: int | None = None,\n        pending_msgs_limit_by_endpoint: int | None = None,\n    ) -&gt; Group:\n        \"\"\"Add a group to the group.\n\n        Args:\n            name: The name of the group. Must be a valid NATS subject prefix.\n            queue_group: The default queue group of the group. When queue group is not set, it defaults to the queue group of the parent group or service.\n            pending_bytes_limit_by_endpoint: The default pending bytes limit for each endpoint within the group.\n            pending_msgs_limit_by_endpoint: The default pending messages limit for each endpoint within the group.\n        \"\"\"\n        config = self._config.child(\n            name=name,\n            queue_group=queue_group,\n            pending_bytes_limit=pending_bytes_limit_by_endpoint,\n            pending_msgs_limit=pending_msgs_limit_by_endpoint,\n        )\n        group = Group(config, self._service)\n        return group\n\n    async def add_endpoint(\n        self,\n        name: str,\n        handler: Handler,\n        subject: str | None = None,\n        queue_group: str | None = None,\n        metadata: dict[str, str] | None = None,\n        pending_bytes_limit: int | None = None,\n        pending_msgs_limit: int | None = None,\n        middlewares: list[Middleware] | None = None,\n    ) -&gt; Endpoint:\n        \"\"\"Add an endpoint to the group.\n\n        Args:\n            name: The name of the endpoint.\n            handler: The handler of the endpoint.\n            subject: The subject of the endpoint. When subject is not set, it defaults to the name of the endpoint.\n            queue_group: The queue group of the endpoint. When queue group is not set, it defaults to the queue group of the parent group or service.\n            metadata: The metadata of the endpoint.\n            pending_bytes_limit: The pending bytes limit for this endpoint.\n            pending_msgs_limit: The pending messages limit for this endpoint.\n        \"\"\"\n        return await self._service.add_endpoint(\n            name=name,\n            subject=f\"{self._config.name}.{subject or name}\",\n            handler=handler,\n            metadata=metadata,\n            queue_group=queue_group or self._config.queue_group,\n            pending_bytes_limit=pending_bytes_limit\n            or self._config.pending_bytes_limit_by_endpoint,\n            pending_msgs_limit=pending_msgs_limit\n            or self._config.pending_msgs_limit_by_endpoint,\n            middlewares=middlewares,\n        )\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.Group.add_endpoint","title":"<code>add_endpoint(name, handler, subject=None, queue_group=None, metadata=None, pending_bytes_limit=None, pending_msgs_limit=None, middlewares=None)</code>  <code>async</code>","text":"<p>Add an endpoint to the group.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the endpoint.</p> required <code>handler</code> <code>Handler</code> <p>The handler of the endpoint.</p> required <code>subject</code> <code>str | None</code> <p>The subject of the endpoint. When subject is not set, it defaults to the name of the endpoint.</p> <code>None</code> <code>queue_group</code> <code>str | None</code> <p>The queue group of the endpoint. When queue group is not set, it defaults to the queue group of the parent group or service.</p> <code>None</code> <code>metadata</code> <code>dict[str, str] | None</code> <p>The metadata of the endpoint.</p> <code>None</code> <code>pending_bytes_limit</code> <code>int | None</code> <p>The pending bytes limit for this endpoint.</p> <code>None</code> <code>pending_msgs_limit</code> <code>int | None</code> <p>The pending messages limit for this endpoint.</p> <code>None</code> Source code in <code>src/nats_contrib/micro/api.py</code> <pre><code>async def add_endpoint(\n    self,\n    name: str,\n    handler: Handler,\n    subject: str | None = None,\n    queue_group: str | None = None,\n    metadata: dict[str, str] | None = None,\n    pending_bytes_limit: int | None = None,\n    pending_msgs_limit: int | None = None,\n    middlewares: list[Middleware] | None = None,\n) -&gt; Endpoint:\n    \"\"\"Add an endpoint to the group.\n\n    Args:\n        name: The name of the endpoint.\n        handler: The handler of the endpoint.\n        subject: The subject of the endpoint. When subject is not set, it defaults to the name of the endpoint.\n        queue_group: The queue group of the endpoint. When queue group is not set, it defaults to the queue group of the parent group or service.\n        metadata: The metadata of the endpoint.\n        pending_bytes_limit: The pending bytes limit for this endpoint.\n        pending_msgs_limit: The pending messages limit for this endpoint.\n    \"\"\"\n    return await self._service.add_endpoint(\n        name=name,\n        subject=f\"{self._config.name}.{subject or name}\",\n        handler=handler,\n        metadata=metadata,\n        queue_group=queue_group or self._config.queue_group,\n        pending_bytes_limit=pending_bytes_limit\n        or self._config.pending_bytes_limit_by_endpoint,\n        pending_msgs_limit=pending_msgs_limit\n        or self._config.pending_msgs_limit_by_endpoint,\n        middlewares=middlewares,\n    )\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.Group.add_group","title":"<code>add_group(name, queue_group=None, pending_bytes_limit_by_endpoint=None, pending_msgs_limit_by_endpoint=None)</code>","text":"<p>Add a group to the group.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the group. Must be a valid NATS subject prefix.</p> required <code>queue_group</code> <code>str | None</code> <p>The default queue group of the group. When queue group is not set, it defaults to the queue group of the parent group or service.</p> <code>None</code> <code>pending_bytes_limit_by_endpoint</code> <code>int | None</code> <p>The default pending bytes limit for each endpoint within the group.</p> <code>None</code> <code>pending_msgs_limit_by_endpoint</code> <code>int | None</code> <p>The default pending messages limit for each endpoint within the group.</p> <code>None</code> Source code in <code>src/nats_contrib/micro/api.py</code> <pre><code>def add_group(\n    self,\n    name: str,\n    queue_group: str | None = None,\n    pending_bytes_limit_by_endpoint: int | None = None,\n    pending_msgs_limit_by_endpoint: int | None = None,\n) -&gt; Group:\n    \"\"\"Add a group to the group.\n\n    Args:\n        name: The name of the group. Must be a valid NATS subject prefix.\n        queue_group: The default queue group of the group. When queue group is not set, it defaults to the queue group of the parent group or service.\n        pending_bytes_limit_by_endpoint: The default pending bytes limit for each endpoint within the group.\n        pending_msgs_limit_by_endpoint: The default pending messages limit for each endpoint within the group.\n    \"\"\"\n    config = self._config.child(\n        name=name,\n        queue_group=queue_group,\n        pending_bytes_limit=pending_bytes_limit_by_endpoint,\n        pending_msgs_limit=pending_msgs_limit_by_endpoint,\n    )\n    group = Group(config, self._service)\n    return group\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.PingInfo","title":"<code>PingInfo</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Base</code></p> <p>The response to a ping message.</p> Source code in <code>src/nats_contrib/micro/models.py</code> <pre><code>@dataclass\nclass PingInfo(Base):\n    \"\"\"The response to a ping message.\"\"\"\n\n    name: str\n    id: str\n    version: str\n    metadata: dict[str, str]\n    type: str = \"io.nats.micro.v1.ping_response\"\n\n    def copy(self) -&gt; PingInfo:\n        return replace(self, metadata=self.metadata.copy())\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.Request","title":"<code>Request</code>","text":"<p>Request is the interface for a request received by a service.</p> <p>An interface is used instead of a class to allow for different implementations. It makes it easy to test a service by using a stub implementation of Request.</p> <p>Four methods must be implemented:</p> <ul> <li><code>def subject() -&gt; str</code>: the subject on which the request was received.</li> <li><code>def headers() -&gt; dict[str, str]</code>: the headers of the request.</li> <li><code>def data() -&gt; bytes</code>: the data of the request.</li> <li><code>async def respond(...) -&gt; None</code>: send a response to the request.</li> </ul> Source code in <code>src/nats_contrib/micro/request.py</code> <pre><code>class Request(metaclass=abc.ABCMeta):\n    \"\"\"Request is the interface for a request received by a service.\n\n    An interface is used instead of a class to allow for different implementations.\n    It makes it easy to test a service by using a stub implementation of Request.\n\n    Four methods must be implemented:\n\n    - `def subject() -&gt; str`: the subject on which the request was received.\n    - `def headers() -&gt; dict[str, str]`: the headers of the request.\n    - `def data() -&gt; bytes`: the data of the request.\n    - `async def respond(...) -&gt; None`: send a response to the request.\n    \"\"\"\n\n    @abc.abstractmethod\n    def subject(self) -&gt; str:\n        \"\"\"The subject on which request was received.\"\"\"\n        raise NotImplementedError()\n\n    @abc.abstractmethod\n    def headers(self) -&gt; dict[str, str]:\n        \"\"\"The headers of the request.\"\"\"\n        raise NotImplementedError()\n\n    @abc.abstractmethod\n    def data(self) -&gt; bytes:\n        \"\"\"The data of the request.\"\"\"\n        raise NotImplementedError()\n\n    @abc.abstractmethod\n    async def respond(self, data: bytes, headers: dict[str, str] | None = None) -&gt; None:\n        \"\"\"Send a success response to the request.\n\n        Args:\n            data: The response data.\n            headers: Additional response headers.\n        \"\"\"\n        raise NotImplementedError()\n\n    async def respond_success(\n        self,\n        code: int,\n        data: bytes | None = None,\n        headers: dict[str, str] | None = None,\n    ) -&gt; None:\n        \"\"\"Send a success response to the request.\n\n        Args:\n            code: The status code describing the success.\n            data: The response data.\n            headers: Additional response headers.\n        \"\"\"\n        if not headers:\n            headers = {}\n        headers[\"Nats-Service-Success-Code\"] = str(code)\n        await self.respond(data or b\"\", headers=headers)\n\n    async def respond_error(\n        self,\n        code: int,\n        description: str,\n        data: bytes | None = None,\n        headers: dict[str, str] | None = None,\n    ) -&gt; None:\n        \"\"\"Send an error response to the request.\n\n        Args:\n            code: The error code describing the error.\n            description: A string describing the error which can be displayed to the client.\n            data: The error data.\n            headers: Additional response headers.\n        \"\"\"\n        if not headers:\n            headers = {}\n        headers[\"Nats-Service-Error\"] = description\n        headers[\"Nats-Service-Error-Code\"] = str(code)\n        await self.respond(data or b\"\", headers=headers)\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.Request.data","title":"<code>data()</code>  <code>abstractmethod</code>","text":"<p>The data of the request.</p> Source code in <code>src/nats_contrib/micro/request.py</code> <pre><code>@abc.abstractmethod\ndef data(self) -&gt; bytes:\n    \"\"\"The data of the request.\"\"\"\n    raise NotImplementedError()\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.Request.headers","title":"<code>headers()</code>  <code>abstractmethod</code>","text":"<p>The headers of the request.</p> Source code in <code>src/nats_contrib/micro/request.py</code> <pre><code>@abc.abstractmethod\ndef headers(self) -&gt; dict[str, str]:\n    \"\"\"The headers of the request.\"\"\"\n    raise NotImplementedError()\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.Request.respond","title":"<code>respond(data, headers=None)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Send a success response to the request.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>bytes</code> <p>The response data.</p> required <code>headers</code> <code>dict[str, str] | None</code> <p>Additional response headers.</p> <code>None</code> Source code in <code>src/nats_contrib/micro/request.py</code> <pre><code>@abc.abstractmethod\nasync def respond(self, data: bytes, headers: dict[str, str] | None = None) -&gt; None:\n    \"\"\"Send a success response to the request.\n\n    Args:\n        data: The response data.\n        headers: Additional response headers.\n    \"\"\"\n    raise NotImplementedError()\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.Request.respond_error","title":"<code>respond_error(code, description, data=None, headers=None)</code>  <code>async</code>","text":"<p>Send an error response to the request.</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>int</code> <p>The error code describing the error.</p> required <code>description</code> <code>str</code> <p>A string describing the error which can be displayed to the client.</p> required <code>data</code> <code>bytes | None</code> <p>The error data.</p> <code>None</code> <code>headers</code> <code>dict[str, str] | None</code> <p>Additional response headers.</p> <code>None</code> Source code in <code>src/nats_contrib/micro/request.py</code> <pre><code>async def respond_error(\n    self,\n    code: int,\n    description: str,\n    data: bytes | None = None,\n    headers: dict[str, str] | None = None,\n) -&gt; None:\n    \"\"\"Send an error response to the request.\n\n    Args:\n        code: The error code describing the error.\n        description: A string describing the error which can be displayed to the client.\n        data: The error data.\n        headers: Additional response headers.\n    \"\"\"\n    if not headers:\n        headers = {}\n    headers[\"Nats-Service-Error\"] = description\n    headers[\"Nats-Service-Error-Code\"] = str(code)\n    await self.respond(data or b\"\", headers=headers)\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.Request.respond_success","title":"<code>respond_success(code, data=None, headers=None)</code>  <code>async</code>","text":"<p>Send a success response to the request.</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>int</code> <p>The status code describing the success.</p> required <code>data</code> <code>bytes | None</code> <p>The response data.</p> <code>None</code> <code>headers</code> <code>dict[str, str] | None</code> <p>Additional response headers.</p> <code>None</code> Source code in <code>src/nats_contrib/micro/request.py</code> <pre><code>async def respond_success(\n    self,\n    code: int,\n    data: bytes | None = None,\n    headers: dict[str, str] | None = None,\n) -&gt; None:\n    \"\"\"Send a success response to the request.\n\n    Args:\n        code: The status code describing the success.\n        data: The response data.\n        headers: Additional response headers.\n    \"\"\"\n    if not headers:\n        headers = {}\n    headers[\"Nats-Service-Success-Code\"] = str(code)\n    await self.respond(data or b\"\", headers=headers)\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.Request.subject","title":"<code>subject()</code>  <code>abstractmethod</code>","text":"<p>The subject on which request was received.</p> Source code in <code>src/nats_contrib/micro/request.py</code> <pre><code>@abc.abstractmethod\ndef subject(self) -&gt; str:\n    \"\"\"The subject on which request was received.\"\"\"\n    raise NotImplementedError()\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.Service","title":"<code>Service</code>","text":"<p>Services simplify the development of NATS micro-services.</p> <p>Endpoints can be added to a service after it has been created and started. Each endpoint is a request-reply handler for a subject.</p> <p>Groups can be added to a service to group endpoints under a common prefix.</p> Source code in <code>src/nats_contrib/micro/api.py</code> <pre><code>class Service:\n    \"\"\"Services simplify the development of NATS micro-services.\n\n    Endpoints can be added to a service after it has been created and started.\n    Each endpoint is a request-reply handler for a subject.\n\n    Groups can be added to a service to group endpoints under a common prefix.\n    \"\"\"\n\n    def __init__(\n        self,\n        nc: NatsClient,\n        id: str,\n        config: internal.ServiceConfig,\n        api_prefix: str,\n        clock: Callable[[], datetime],\n    ) -&gt; None:\n        self._nc = nc\n        self._config = config\n        self._api_prefix = api_prefix\n        self._clock = clock\n        # Initialize state\n        self._id = id\n        self._endpoints: list[Endpoint] = []\n        self._stopped = False\n        # Internal responses\n        self._stats = internal.new_service_stats(self._id, self._clock(), config)\n        self._info = internal.new_service_info(self._id, config)\n        self._ping_response = internal.new_ping_info(self._id, config)\n        # Cache the serialized ping response\n        self._ping_response_message = internal.encode_ping_info(self._ping_response)\n        # Internal subscriptions\n        self._ping_subscriptions: list[Subscription] = []\n        self._info_subscriptions: list[Subscription] = []\n        self._stats_subscriptions: list[Subscription] = []\n\n    async def start(self) -&gt; None:\n        \"\"\"Start the service.\n\n        A service MUST be started before adding endpoints.\n\n        This will start the internal subscriptions and enable\n        service discovery.\n        \"\"\"\n        # Start PING subscriptions:\n        # - $SRV.PING\n        # - $SRV.{name}.PING\n        # - $SRV.{name}.{id}.PING\n        for subject in internal.get_internal_subjects(\n            internal.ServiceVerb.PING,\n            self._id,\n            self._config,\n            api_prefix=self._api_prefix,\n        ):\n            sub = await self._nc.subscribe(  # pyright: ignore[reportUnknownMemberType]\n                subject,\n                cb=self._handle_ping_request,\n            )\n            self._ping_subscriptions.append(sub)\n        # Start INFO subscriptions:\n        # - $SRV.INFO\n        # - $SRV.{name}.INFO\n        # - $SRV.{name}.{id}.INFO\n        for subject in internal.get_internal_subjects(\n            internal.ServiceVerb.INFO,\n            self._id,\n            self._config,\n            api_prefix=self._api_prefix,\n        ):\n            sub = await self._nc.subscribe(  # pyright: ignore[reportUnknownMemberType]\n                subject,\n                cb=self._handle_info_request,\n            )\n            self._info_subscriptions.append(sub)\n        # Start STATS subscriptions:\n        # - $SRV.STATS\n        # - $SRV.{name}.STATS\n        # - $SRV.{name}.{id}.STATS\n        for subject in internal.get_internal_subjects(\n            internal.ServiceVerb.STATS,\n            self._id,\n            self._config,\n            api_prefix=self._api_prefix,\n        ):\n            sub = await self._nc.subscribe(  # pyright: ignore[reportUnknownMemberType]\n                subject,\n                cb=self._handle_stats_request,\n            )\n            self._stats_subscriptions.append(sub)\n\n    async def stop(self) -&gt; None:\n        \"\"\"Stop the service.\n\n        This will stop all endpoints and internal subscriptions.\n        \"\"\"\n        self._stopped = True\n        # Stop all endpoints\n        await asyncio.gather(*(_stop_endpoint(ep) for ep in self._endpoints))\n        # Stop all internal subscriptions\n        await asyncio.gather(\n            *(\n                _unsubscribe(sub)\n                for subscriptions in (\n                    self._stats_subscriptions,\n                    self._info_subscriptions,\n                    self._ping_subscriptions,\n                )\n                for sub in subscriptions\n            )\n        )\n\n    def stopped(self) -&gt; bool:\n        \"\"\"Stopped informs whether [Stop] was executed on the service.\"\"\"\n        return self._stopped\n\n    def info(self) -&gt; ServiceInfo:\n        \"\"\"Returns the service info.\"\"\"\n        return self._info.copy()\n\n    def stats(self) -&gt; ServiceStats:\n        \"\"\"Returns statistics for the service endpoint and all monitoring endpoints.\"\"\"\n        return self._stats.copy()\n\n    def reset(self) -&gt; None:\n        \"\"\"Resets all statistics (for all endpoints) on a service instance.\"\"\"\n\n        # Internal responses\n        self._stats = internal.new_service_stats(self._id, self._clock(), self._config)\n        self._info = internal.new_service_info(self._id, self._config)\n        self._ping_response = internal.new_ping_info(self._id, self._config)\n        self._ping_response_message = internal.encode_ping_info(self._ping_response)\n        # Reset all endpoints\n        endpoints = list(self._endpoints)\n        self._endpoints.clear()\n        for ep in endpoints:\n            ep.reset()\n            self._endpoints.append(ep)\n            self._stats.endpoints.append(ep.stats)\n            self._info.endpoints.append(ep.info)\n\n    def add_group(\n        self,\n        name: str,\n        queue_group: str | None = None,\n        pending_bytes_limit_by_endpoint: int | None = None,\n        pending_msgs_limit_by_endpoint: int | None = None,\n    ) -&gt; Group:\n        \"\"\"Add a group to the service.\n\n        A group is a collection of endpoints that share the same prefix,\n        and the same default queue group and pending limits.\n\n        At runtime, a group does not exist as a separate entity, only\n        endpoints exist. However, groups are useful to organize endpoints\n        and to set default values for queue group and pending limits.\n\n        Args:\n            name: The name of the group.\n            queue_group: The default queue group of the group. When queue group is not set, it defaults to the queue group of the parent group or service.\n            pending_bytes_limit_by_endpoint: The default pending bytes limit for each endpoint within the group.\n            pending_msgs_limit_by_endpoint: The default pending messages limit for each endpoint within the group.\n        \"\"\"\n        config = internal.GroupConfig(\n            name=name,\n            queue_group=queue_group or self._config.queue_group,\n            pending_bytes_limit_by_endpoint=pending_bytes_limit_by_endpoint\n            or self._config.pending_bytes_limit_by_endpoint,\n            pending_msgs_limit_by_endpoint=pending_msgs_limit_by_endpoint\n            or self._config.pending_msgs_limit_by_endpoint,\n        )\n        return Group(config, self)\n\n    async def add_endpoint(\n        self,\n        name: str,\n        handler: Handler,\n        subject: str | None = None,\n        queue_group: str | None = None,\n        metadata: dict[str, str] | None = None,\n        pending_bytes_limit: int | None = None,\n        pending_msgs_limit: int | None = None,\n        middlewares: list[Middleware] | None = None,\n    ) -&gt; Endpoint:\n        \"\"\"Add an endpoint to the service.\n\n        An endpoint is a request-reply handler for a subject.\n\n        Args:\n            name: The name of the endpoint.\n            handler: The handler of the endpoint.\n            subject: The subject of the endpoint. When subject is not set, it defaults to the name of the endpoint.\n            queue_group: The queue group of the endpoint. When queue group is not set, it defaults to the queue group of the parent group or service.\n            metadata: The metadata of the endpoint.\n            pending_bytes_limit: The pending bytes limit for this endpoint.\n            pending_msgs_limit: The pending messages limit for this endpoint.\n        \"\"\"\n        if self._stopped:\n            raise RuntimeError(\"Cannot add endpoint to a stopped service\")\n        config = self._config.endpoint_config(\n            name=name,\n            handler=handler,\n            subject=subject,\n            queue_group=queue_group,\n            metadata=metadata,\n            pending_bytes_limit=pending_bytes_limit,\n            pending_msgs_limit=pending_msgs_limit,\n        )\n        # Create the endpoint\n        ep = Endpoint(config)\n        # Create the endpoint handler\n        subscription_handler = _create_handler(ep, middlewares)\n        # Start the endpoint subscription\n        subscription = (\n            await self._nc.subscribe(  # pyright: ignore[reportUnknownMemberType]\n                config.subject,\n                queue=config.queue_group,\n                cb=subscription_handler,\n            )\n        )\n        # Attach the subscription to the endpoint\n        ep._sub = subscription  # pyright: ignore[reportPrivateUsage]\n        # Append the endpoint to the service\n        self._endpoints.append(ep)\n        # Append the endpoint to the service stats and info\n        self._stats.endpoints.append(ep.stats)\n        self._info.endpoints.append(ep.info)\n        return ep\n\n    async def _handle_ping_request(self, msg: Msg) -&gt; None:\n        \"\"\"Handle the ping message.\"\"\"\n        await msg.respond(data=self._ping_response_message)\n\n    async def _handle_info_request(self, msg: Msg) -&gt; None:\n        \"\"\"Handle the info message.\"\"\"\n        await msg.respond(data=internal.encode_info(self._info))\n\n    async def _handle_stats_request(self, msg: Msg) -&gt; None:\n        \"\"\"Handle the stats message.\"\"\"\n        await msg.respond(data=internal.encode_stats(self._stats))\n\n    async def __aenter__(self) -&gt; Service:\n        \"\"\"Implement the asynchronous context manager interface.\"\"\"\n        await self.start()\n        return self\n\n    async def __aexit__(self, *args: object, **kwargs: object) -&gt; None:\n        \"\"\"Implement the asynchronous context manager interface.\"\"\"\n        await self.stop()\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.Service.__aenter__","title":"<code>__aenter__()</code>  <code>async</code>","text":"<p>Implement the asynchronous context manager interface.</p> Source code in <code>src/nats_contrib/micro/api.py</code> <pre><code>async def __aenter__(self) -&gt; Service:\n    \"\"\"Implement the asynchronous context manager interface.\"\"\"\n    await self.start()\n    return self\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.Service.__aexit__","title":"<code>__aexit__(*args, **kwargs)</code>  <code>async</code>","text":"<p>Implement the asynchronous context manager interface.</p> Source code in <code>src/nats_contrib/micro/api.py</code> <pre><code>async def __aexit__(self, *args: object, **kwargs: object) -&gt; None:\n    \"\"\"Implement the asynchronous context manager interface.\"\"\"\n    await self.stop()\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.Service.add_endpoint","title":"<code>add_endpoint(name, handler, subject=None, queue_group=None, metadata=None, pending_bytes_limit=None, pending_msgs_limit=None, middlewares=None)</code>  <code>async</code>","text":"<p>Add an endpoint to the service.</p> <p>An endpoint is a request-reply handler for a subject.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the endpoint.</p> required <code>handler</code> <code>Handler</code> <p>The handler of the endpoint.</p> required <code>subject</code> <code>str | None</code> <p>The subject of the endpoint. When subject is not set, it defaults to the name of the endpoint.</p> <code>None</code> <code>queue_group</code> <code>str | None</code> <p>The queue group of the endpoint. When queue group is not set, it defaults to the queue group of the parent group or service.</p> <code>None</code> <code>metadata</code> <code>dict[str, str] | None</code> <p>The metadata of the endpoint.</p> <code>None</code> <code>pending_bytes_limit</code> <code>int | None</code> <p>The pending bytes limit for this endpoint.</p> <code>None</code> <code>pending_msgs_limit</code> <code>int | None</code> <p>The pending messages limit for this endpoint.</p> <code>None</code> Source code in <code>src/nats_contrib/micro/api.py</code> <pre><code>async def add_endpoint(\n    self,\n    name: str,\n    handler: Handler,\n    subject: str | None = None,\n    queue_group: str | None = None,\n    metadata: dict[str, str] | None = None,\n    pending_bytes_limit: int | None = None,\n    pending_msgs_limit: int | None = None,\n    middlewares: list[Middleware] | None = None,\n) -&gt; Endpoint:\n    \"\"\"Add an endpoint to the service.\n\n    An endpoint is a request-reply handler for a subject.\n\n    Args:\n        name: The name of the endpoint.\n        handler: The handler of the endpoint.\n        subject: The subject of the endpoint. When subject is not set, it defaults to the name of the endpoint.\n        queue_group: The queue group of the endpoint. When queue group is not set, it defaults to the queue group of the parent group or service.\n        metadata: The metadata of the endpoint.\n        pending_bytes_limit: The pending bytes limit for this endpoint.\n        pending_msgs_limit: The pending messages limit for this endpoint.\n    \"\"\"\n    if self._stopped:\n        raise RuntimeError(\"Cannot add endpoint to a stopped service\")\n    config = self._config.endpoint_config(\n        name=name,\n        handler=handler,\n        subject=subject,\n        queue_group=queue_group,\n        metadata=metadata,\n        pending_bytes_limit=pending_bytes_limit,\n        pending_msgs_limit=pending_msgs_limit,\n    )\n    # Create the endpoint\n    ep = Endpoint(config)\n    # Create the endpoint handler\n    subscription_handler = _create_handler(ep, middlewares)\n    # Start the endpoint subscription\n    subscription = (\n        await self._nc.subscribe(  # pyright: ignore[reportUnknownMemberType]\n            config.subject,\n            queue=config.queue_group,\n            cb=subscription_handler,\n        )\n    )\n    # Attach the subscription to the endpoint\n    ep._sub = subscription  # pyright: ignore[reportPrivateUsage]\n    # Append the endpoint to the service\n    self._endpoints.append(ep)\n    # Append the endpoint to the service stats and info\n    self._stats.endpoints.append(ep.stats)\n    self._info.endpoints.append(ep.info)\n    return ep\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.Service.add_group","title":"<code>add_group(name, queue_group=None, pending_bytes_limit_by_endpoint=None, pending_msgs_limit_by_endpoint=None)</code>","text":"<p>Add a group to the service.</p> <p>A group is a collection of endpoints that share the same prefix, and the same default queue group and pending limits.</p> <p>At runtime, a group does not exist as a separate entity, only endpoints exist. However, groups are useful to organize endpoints and to set default values for queue group and pending limits.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the group.</p> required <code>queue_group</code> <code>str | None</code> <p>The default queue group of the group. When queue group is not set, it defaults to the queue group of the parent group or service.</p> <code>None</code> <code>pending_bytes_limit_by_endpoint</code> <code>int | None</code> <p>The default pending bytes limit for each endpoint within the group.</p> <code>None</code> <code>pending_msgs_limit_by_endpoint</code> <code>int | None</code> <p>The default pending messages limit for each endpoint within the group.</p> <code>None</code> Source code in <code>src/nats_contrib/micro/api.py</code> <pre><code>def add_group(\n    self,\n    name: str,\n    queue_group: str | None = None,\n    pending_bytes_limit_by_endpoint: int | None = None,\n    pending_msgs_limit_by_endpoint: int | None = None,\n) -&gt; Group:\n    \"\"\"Add a group to the service.\n\n    A group is a collection of endpoints that share the same prefix,\n    and the same default queue group and pending limits.\n\n    At runtime, a group does not exist as a separate entity, only\n    endpoints exist. However, groups are useful to organize endpoints\n    and to set default values for queue group and pending limits.\n\n    Args:\n        name: The name of the group.\n        queue_group: The default queue group of the group. When queue group is not set, it defaults to the queue group of the parent group or service.\n        pending_bytes_limit_by_endpoint: The default pending bytes limit for each endpoint within the group.\n        pending_msgs_limit_by_endpoint: The default pending messages limit for each endpoint within the group.\n    \"\"\"\n    config = internal.GroupConfig(\n        name=name,\n        queue_group=queue_group or self._config.queue_group,\n        pending_bytes_limit_by_endpoint=pending_bytes_limit_by_endpoint\n        or self._config.pending_bytes_limit_by_endpoint,\n        pending_msgs_limit_by_endpoint=pending_msgs_limit_by_endpoint\n        or self._config.pending_msgs_limit_by_endpoint,\n    )\n    return Group(config, self)\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.Service.info","title":"<code>info()</code>","text":"<p>Returns the service info.</p> Source code in <code>src/nats_contrib/micro/api.py</code> <pre><code>def info(self) -&gt; ServiceInfo:\n    \"\"\"Returns the service info.\"\"\"\n    return self._info.copy()\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.Service.reset","title":"<code>reset()</code>","text":"<p>Resets all statistics (for all endpoints) on a service instance.</p> Source code in <code>src/nats_contrib/micro/api.py</code> <pre><code>def reset(self) -&gt; None:\n    \"\"\"Resets all statistics (for all endpoints) on a service instance.\"\"\"\n\n    # Internal responses\n    self._stats = internal.new_service_stats(self._id, self._clock(), self._config)\n    self._info = internal.new_service_info(self._id, self._config)\n    self._ping_response = internal.new_ping_info(self._id, self._config)\n    self._ping_response_message = internal.encode_ping_info(self._ping_response)\n    # Reset all endpoints\n    endpoints = list(self._endpoints)\n    self._endpoints.clear()\n    for ep in endpoints:\n        ep.reset()\n        self._endpoints.append(ep)\n        self._stats.endpoints.append(ep.stats)\n        self._info.endpoints.append(ep.info)\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.Service.start","title":"<code>start()</code>  <code>async</code>","text":"<p>Start the service.</p> <p>A service MUST be started before adding endpoints.</p> <p>This will start the internal subscriptions and enable service discovery.</p> Source code in <code>src/nats_contrib/micro/api.py</code> <pre><code>async def start(self) -&gt; None:\n    \"\"\"Start the service.\n\n    A service MUST be started before adding endpoints.\n\n    This will start the internal subscriptions and enable\n    service discovery.\n    \"\"\"\n    # Start PING subscriptions:\n    # - $SRV.PING\n    # - $SRV.{name}.PING\n    # - $SRV.{name}.{id}.PING\n    for subject in internal.get_internal_subjects(\n        internal.ServiceVerb.PING,\n        self._id,\n        self._config,\n        api_prefix=self._api_prefix,\n    ):\n        sub = await self._nc.subscribe(  # pyright: ignore[reportUnknownMemberType]\n            subject,\n            cb=self._handle_ping_request,\n        )\n        self._ping_subscriptions.append(sub)\n    # Start INFO subscriptions:\n    # - $SRV.INFO\n    # - $SRV.{name}.INFO\n    # - $SRV.{name}.{id}.INFO\n    for subject in internal.get_internal_subjects(\n        internal.ServiceVerb.INFO,\n        self._id,\n        self._config,\n        api_prefix=self._api_prefix,\n    ):\n        sub = await self._nc.subscribe(  # pyright: ignore[reportUnknownMemberType]\n            subject,\n            cb=self._handle_info_request,\n        )\n        self._info_subscriptions.append(sub)\n    # Start STATS subscriptions:\n    # - $SRV.STATS\n    # - $SRV.{name}.STATS\n    # - $SRV.{name}.{id}.STATS\n    for subject in internal.get_internal_subjects(\n        internal.ServiceVerb.STATS,\n        self._id,\n        self._config,\n        api_prefix=self._api_prefix,\n    ):\n        sub = await self._nc.subscribe(  # pyright: ignore[reportUnknownMemberType]\n            subject,\n            cb=self._handle_stats_request,\n        )\n        self._stats_subscriptions.append(sub)\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.Service.stats","title":"<code>stats()</code>","text":"<p>Returns statistics for the service endpoint and all monitoring endpoints.</p> Source code in <code>src/nats_contrib/micro/api.py</code> <pre><code>def stats(self) -&gt; ServiceStats:\n    \"\"\"Returns statistics for the service endpoint and all monitoring endpoints.\"\"\"\n    return self._stats.copy()\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.Service.stop","title":"<code>stop()</code>  <code>async</code>","text":"<p>Stop the service.</p> <p>This will stop all endpoints and internal subscriptions.</p> Source code in <code>src/nats_contrib/micro/api.py</code> <pre><code>async def stop(self) -&gt; None:\n    \"\"\"Stop the service.\n\n    This will stop all endpoints and internal subscriptions.\n    \"\"\"\n    self._stopped = True\n    # Stop all endpoints\n    await asyncio.gather(*(_stop_endpoint(ep) for ep in self._endpoints))\n    # Stop all internal subscriptions\n    await asyncio.gather(\n        *(\n            _unsubscribe(sub)\n            for subscriptions in (\n                self._stats_subscriptions,\n                self._info_subscriptions,\n                self._ping_subscriptions,\n            )\n            for sub in subscriptions\n        )\n    )\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.Service.stopped","title":"<code>stopped()</code>","text":"<p>Stopped informs whether [Stop] was executed on the service.</p> Source code in <code>src/nats_contrib/micro/api.py</code> <pre><code>def stopped(self) -&gt; bool:\n    \"\"\"Stopped informs whether [Stop] was executed on the service.\"\"\"\n    return self._stopped\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.ServiceError","title":"<code>ServiceError</code>","text":"<p>             Bases: <code>Exception</code></p> <p>Raised when a service error is received.</p> Source code in <code>src/nats_contrib/micro/client.py</code> <pre><code>class ServiceError(Exception):\n    \"\"\"Raised when a service error is received.\"\"\"\n\n    def __init__(\n        self,\n        code: int,\n        description: str,\n        subject: str,\n        data: bytes,\n        headers: dict[str, str],\n    ) -&gt; None:\n        super().__init__(f\"Service error {code}: {description}\")\n        self.code = code\n        self.description = description\n        self.subject = subject\n        self.data = data\n        self.headers = headers\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.ServiceInfo","title":"<code>ServiceInfo</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Base</code></p> <p>The information of a service.</p> Source code in <code>src/nats_contrib/micro/models.py</code> <pre><code>@dataclass\nclass ServiceInfo(Base):\n    \"\"\"The information of a service.\"\"\"\n\n    name: str\n    \"\"\"\n    The kind of the service. Shared by all the services that have the same name\n    \"\"\"\n    id: str\n    \"\"\"\n    A unique ID for this instance of a service\n    \"\"\"\n    version: str\n    \"\"\"\n    The version of the service\n    \"\"\"\n    description: str\n    \"\"\"\n    The description of the service supplied as configuration while creating the service\n    \"\"\"\n    metadata: dict[str, str]\n    \"\"\"\n    The service metadata\n    \"\"\"\n    endpoints: list[EndpointInfo]\n    \"\"\"\n    Information for all service endpoints\n    \"\"\"\n    type: str = \"io.nats.micro.v1.info_response\"\n\n    def copy(self) -&gt; ServiceInfo:\n        return replace(\n            self,\n            endpoints=[ep.copy() for ep in self.endpoints],\n            metadata=self.metadata.copy(),\n        )\n\n    def as_dict(self) -&gt; dict[str, Any]:\n        \"\"\"Return the object converted into an API-friendly dict.\"\"\"\n        result = super().as_dict()\n        result[\"endpoints\"] = [ep.as_dict() for ep in self.endpoints]\n        return result\n\n    @classmethod\n    def from_response(cls, resp: dict[str, Any]) -&gt; ServiceInfo:\n        \"\"\"Read the class instance from a server response.\n\n        Unknown fields are ignored (\"open-world assumption\").\n        \"\"\"\n        info = super().from_response(resp)\n        info.endpoints = [EndpointInfo(**ep) for ep in resp[\"endpoints\"]]\n        return info\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.ServiceInfo.description","title":"<code>description: str</code>  <code>instance-attribute</code>","text":"<p>The description of the service supplied as configuration while creating the service</p>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.ServiceInfo.endpoints","title":"<code>endpoints: list[EndpointInfo]</code>  <code>instance-attribute</code>","text":"<p>Information for all service endpoints</p>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.ServiceInfo.id","title":"<code>id: str</code>  <code>instance-attribute</code>","text":"<p>A unique ID for this instance of a service</p>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.ServiceInfo.metadata","title":"<code>metadata: dict[str, str]</code>  <code>instance-attribute</code>","text":"<p>The service metadata</p>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.ServiceInfo.name","title":"<code>name: str</code>  <code>instance-attribute</code>","text":"<p>The kind of the service. Shared by all the services that have the same name</p>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.ServiceInfo.version","title":"<code>version: str</code>  <code>instance-attribute</code>","text":"<p>The version of the service</p>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.ServiceInfo.as_dict","title":"<code>as_dict()</code>","text":"<p>Return the object converted into an API-friendly dict.</p> Source code in <code>src/nats_contrib/micro/models.py</code> <pre><code>def as_dict(self) -&gt; dict[str, Any]:\n    \"\"\"Return the object converted into an API-friendly dict.\"\"\"\n    result = super().as_dict()\n    result[\"endpoints\"] = [ep.as_dict() for ep in self.endpoints]\n    return result\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.ServiceInfo.from_response","title":"<code>from_response(resp)</code>  <code>classmethod</code>","text":"<p>Read the class instance from a server response.</p> <p>Unknown fields are ignored (\"open-world assumption\").</p> Source code in <code>src/nats_contrib/micro/models.py</code> <pre><code>@classmethod\ndef from_response(cls, resp: dict[str, Any]) -&gt; ServiceInfo:\n    \"\"\"Read the class instance from a server response.\n\n    Unknown fields are ignored (\"open-world assumption\").\n    \"\"\"\n    info = super().from_response(resp)\n    info.endpoints = [EndpointInfo(**ep) for ep in resp[\"endpoints\"]]\n    return info\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.ServiceStats","title":"<code>ServiceStats</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Base</code></p> <p>The statistics of a service.</p> Source code in <code>src/nats_contrib/micro/models.py</code> <pre><code>@dataclass\nclass ServiceStats(Base):\n    \"\"\"The statistics of a service.\"\"\"\n\n    name: str\n    \"\"\"\n    The kind of the service. Shared by all the services that have the same name\n    \"\"\"\n    id: str\n    \"\"\"\n    A unique ID for this instance of a service\n    \"\"\"\n    version: str\n    \"\"\"\n    The version of the service\n    \"\"\"\n    started: datetime.datetime\n    \"\"\"\n    The time the service was stated in RFC3339 format\n    \"\"\"\n    endpoints: list[EndpointStats]\n    \"\"\"\n    Statistics for each known endpoint\n    \"\"\"\n    metadata: dict[str, str] | None = None\n    \"\"\"Service metadata.\"\"\"\n\n    type: str = \"io.nats.micro.v1.stats_response\"\n\n    def copy(self) -&gt; ServiceStats:\n        return replace(\n            self,\n            endpoints=[ep.copy() for ep in self.endpoints],\n            metadata=None if self.metadata is None else self.metadata.copy(),\n        )\n\n    def as_dict(self) -&gt; dict[str, Any]:\n        \"\"\"Return the object converted into an API-friendly dict.\"\"\"\n        result = super().as_dict()\n        result[\"endpoints\"] = [ep.as_dict() for ep in self.endpoints]\n        result[\"started\"] = self._to_rfc3339(self.started)\n        return result\n\n    @classmethod\n    def from_response(cls, resp: dict[str, Any]) -&gt; ServiceStats:\n        \"\"\"Read the class instance from a server response.\n\n        Unknown fields are ignored (\"open-world assumption\").\n        \"\"\"\n        cls._convert_rfc3339(resp, \"started\")\n        stats = super().from_response(resp)\n        stats.endpoints = [EndpointStats.from_response(ep) for ep in resp[\"endpoints\"]]\n        return stats\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.ServiceStats.endpoints","title":"<code>endpoints: list[EndpointStats]</code>  <code>instance-attribute</code>","text":"<p>Statistics for each known endpoint</p>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.ServiceStats.id","title":"<code>id: str</code>  <code>instance-attribute</code>","text":"<p>A unique ID for this instance of a service</p>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.ServiceStats.metadata","title":"<code>metadata: dict[str, str] | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Service metadata.</p>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.ServiceStats.name","title":"<code>name: str</code>  <code>instance-attribute</code>","text":"<p>The kind of the service. Shared by all the services that have the same name</p>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.ServiceStats.started","title":"<code>started: datetime.datetime</code>  <code>instance-attribute</code>","text":"<p>The time the service was stated in RFC3339 format</p>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.ServiceStats.version","title":"<code>version: str</code>  <code>instance-attribute</code>","text":"<p>The version of the service</p>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.ServiceStats.as_dict","title":"<code>as_dict()</code>","text":"<p>Return the object converted into an API-friendly dict.</p> Source code in <code>src/nats_contrib/micro/models.py</code> <pre><code>def as_dict(self) -&gt; dict[str, Any]:\n    \"\"\"Return the object converted into an API-friendly dict.\"\"\"\n    result = super().as_dict()\n    result[\"endpoints\"] = [ep.as_dict() for ep in self.endpoints]\n    result[\"started\"] = self._to_rfc3339(self.started)\n    return result\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.ServiceStats.from_response","title":"<code>from_response(resp)</code>  <code>classmethod</code>","text":"<p>Read the class instance from a server response.</p> <p>Unknown fields are ignored (\"open-world assumption\").</p> Source code in <code>src/nats_contrib/micro/models.py</code> <pre><code>@classmethod\ndef from_response(cls, resp: dict[str, Any]) -&gt; ServiceStats:\n    \"\"\"Read the class instance from a server response.\n\n    Unknown fields are ignored (\"open-world assumption\").\n    \"\"\"\n    cls._convert_rfc3339(resp, \"started\")\n    stats = super().from_response(resp)\n    stats.endpoints = [EndpointStats.from_response(ep) for ep in resp[\"endpoints\"]]\n    return stats\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.add_service","title":"<code>add_service(nc, name, version, description=None, metadata=None, queue_group=None, pending_bytes_limit_by_endpoint=None, pending_msgs_limit_by_endpoint=None, now=None, id_generator=None, api_prefix=None)</code>","text":"<p>Create a new service.</p> <p>A service is a collection of endpoints that are grouped together under a common name.</p> <p>Each endpoint is a request-reply handler for a subject.</p> <p>It's possible to add endpoints to a service after it has been created AND started.</p> <p>Parameters:</p> Name Type Description Default <code>nc</code> <code>Client</code> <p>The NATS client.</p> required <code>name</code> <code>str</code> <p>The name of the service.</p> required <code>version</code> <code>str</code> <p>The version of the service. Must be a valid semver version.</p> required <code>description</code> <code>str | None</code> <p>The description of the service.</p> <code>None</code> <code>metadata</code> <code>dict[str, str] | None</code> <p>The metadata of the service.</p> <code>None</code> <code>queue_group</code> <code>str | None</code> <p>The default queue group of the service.</p> <code>None</code> <code>pending_bytes_limit_by_endpoint</code> <code>int | None</code> <p>The default pending bytes limit for each endpoint within the service.</p> <code>None</code> <code>pending_msgs_limit_by_endpoint</code> <code>int | None</code> <p>The default pending messages limit for each endpoint within the service.</p> <code>None</code> <code>now</code> <code>Callable[[], datetime] | None</code> <p>The function to get the current time.</p> <code>None</code> <code>id_generator</code> <code>Callable[[], str] | None</code> <p>The function to generate a unique service instance id.</p> <code>None</code> <code>api_prefix</code> <code>str | None</code> <p>The prefix of the control subjects.</p> <code>None</code> Source code in <code>src/nats_contrib/micro/api.py</code> <pre><code>def add_service(\n    nc: NatsClient,\n    name: str,\n    version: str,\n    description: str | None = None,\n    metadata: dict[str, str] | None = None,\n    queue_group: str | None = None,\n    pending_bytes_limit_by_endpoint: int | None = None,\n    pending_msgs_limit_by_endpoint: int | None = None,\n    now: Callable[[], datetime] | None = None,\n    id_generator: Callable[[], str] | None = None,\n    api_prefix: str | None = None,\n) -&gt; Service:\n    \"\"\"Create a new service.\n\n    A service is a collection of endpoints that are grouped together\n    under a common name.\n\n    Each endpoint is a request-reply handler for a subject.\n\n    It's possible to add endpoints to a service after it has been created AND\n    started.\n\n    Args:\n        nc: The NATS client.\n        name: The name of the service.\n        version: The version of the service. Must be a valid semver version.\n        description: The description of the service.\n        metadata: The metadata of the service.\n        queue_group: The default queue group of the service.\n        pending_bytes_limit_by_endpoint: The default pending bytes limit for each endpoint within the service.\n        pending_msgs_limit_by_endpoint: The default pending messages limit for each endpoint within the service.\n        now: The function to get the current time.\n        id_generator: The function to generate a unique service instance id.\n        api_prefix: The prefix of the control subjects.\n    \"\"\"\n    if id_generator is None:\n        id_generator = internal.default_id_generator\n    instance_id = id_generator()\n    service_config = internal.ServiceConfig(\n        name=name,\n        version=version,\n        description=description or \"\",\n        metadata=metadata or {},\n        queue_group=queue_group or DEFAULT_QUEUE_GROUP,\n        pending_bytes_limit_by_endpoint=pending_bytes_limit_by_endpoint\n        or DEFAULT_SUB_PENDING_BYTES_LIMIT,\n        pending_msgs_limit_by_endpoint=pending_msgs_limit_by_endpoint\n        or DEFAULT_SUB_PENDING_MSGS_LIMIT,\n    )\n    return Service(\n        nc=nc,\n        id=instance_id,\n        config=service_config,\n        api_prefix=api_prefix or API_PREFIX,\n        clock=now or internal.default_clock,\n    )\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.run","title":"<code>run(setup, /, *options, trap_signals=False, client=None)</code>","text":"<p>Helper function to run an async program.</p> Source code in <code>src/nats_contrib/micro/context.py</code> <pre><code>def run(\n    setup: Callable[[Context], Coroutine[Any, Any, None]],\n    /,\n    *options: ConnectOption,\n    trap_signals: bool | tuple[signal.Signals, ...] = False,\n    client: NATS | None = None,\n) -&gt; None:\n    \"\"\"Helper function to run an async program.\"\"\"\n\n    asyncio.run(\n        Context(client=client).run_forever(\n            setup,\n            *options,\n            trap_signals=trap_signals,\n        )\n    )\n</code></pre>"},{"location":"reference/nats_contrib/micro/cli/","title":"Index","text":""},{"location":"reference/nats_contrib/micro/cli/commands/","title":"Index","text":""},{"location":"reference/nats_contrib/micro/cli/utils/","title":"Index","text":""},{"location":"reference/nats_contrib/micro/cli/utils/#nats_contrib.micro.cli.utils.Flag","title":"<code>Flag</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Generic[T]</code></p> <p>A command line flag.</p> <p>This class is used to centralize the definition of command line flags and their default values. It is useful especially when the same flag is used both as a global option and as a subcommand option.</p> <p>It also allows to get the value of the flag from the command line arguments or from the environment variables.</p> Source code in <code>src/nats_contrib/micro/cli/utils/flags.py</code> <pre><code>@dataclass\nclass Flag(Generic[T]):\n    \"\"\"A command line flag.\n\n    This class is used to centralize the definition of command line\n    flags and their default values. It is useful especially when\n    the same flag is used both as a global option and as a subcommand\n    option.\n\n    It also allows to get the value of the flag from the command line arguments or from the environment\n    variables.\n    \"\"\"\n\n    name: str\n    metavar: str\n    type: type[T]\n    help: str\n    env: str | None = None\n    env_transform: Callable[[str], T] | None = None\n    default: T = ...  # type: ignore\n    alias: list[str] | None = None\n    short_option: str | None = None\n\n    def add_as_global_option(self, parser: argparse.ArgumentParser) -&gt; None:\n        \"\"\"Add the argument to the parser.\"\"\"\n        kwargs: dict[str, Any] = {}\n        args: list[str] = []\n        if self.alias:\n            args.extend(self.alias)\n        if self.short_option:\n            args.append(self.short_option)\n        if self.default is not ...:\n            kwargs[\"help\"] = f\"{self.help} (default: {self.default})\"\n        else:\n            kwargs[\"help\"] = self.help\n        if self.type is bool and self.default is False:\n            kwargs[\"action\"] = \"store_true\"\n        parser.add_argument(\n            f\"--{self.name.replace('_', '-')}\",\n            *args,\n            metavar=self.metavar,\n            type=self.type,\n            **kwargs,\n        )\n\n    def add_as_subcommand_option(self, parser: argparse.ArgumentParser) -&gt; None:\n        \"\"\"Add the argument to the parser.\"\"\"\n        kwargs: dict[str, Any] = {}\n        args: list[str] = []\n        if self.alias:\n            args.extend(self.alias)\n        if self.short_option:\n            args.append(self.short_option)\n        extras: list[str] = []\n        if self.default is not ...:\n            extras.append(f\"(default: {self.default})\")\n        if self.env is not None:\n            extras.append(f\"(env: {self.env})\")\n        if extras:\n            kwargs[\"help\"] = f\"{self.help} {' '.join(extras)}\"\n        else:\n            kwargs[\"help\"] = self.help\n        if self.type is bool and self.default is False:\n            kwargs[\"action\"] = \"store_true\"\n        parser.add_argument(\n            f\"--{self.name.replace('_', '-')}\",\n            *args,\n            metavar=self.metavar,\n            type=self.type,\n            dest=f\"{self.name}_\",\n            **kwargs,\n        )\n\n    def get(self, args: argparse.Namespace) -&gt; T:\n        \"\"\"Get the value of the argument from the namespace.\"\"\"\n        local = getattr(args, f\"{self.name}_\", None)\n        if local is not None:\n            return local\n        value = getattr(args, self.name, None)\n        if value is not None:\n            return value\n        if self.env is not None:\n            value = os.environ.get(self.env, None)\n            if value is not None:\n                if self.env_transform is not None:\n                    return self.env_transform(value)\n                return self.type(value)\n        if self.default is not ...:\n            return self.default\n\n        raise ValueError(f\"missing argument: {self.name}\")\n</code></pre>"},{"location":"reference/nats_contrib/micro/cli/utils/#nats_contrib.micro.cli.utils.Flag.add_as_global_option","title":"<code>add_as_global_option(parser)</code>","text":"<p>Add the argument to the parser.</p> Source code in <code>src/nats_contrib/micro/cli/utils/flags.py</code> <pre><code>def add_as_global_option(self, parser: argparse.ArgumentParser) -&gt; None:\n    \"\"\"Add the argument to the parser.\"\"\"\n    kwargs: dict[str, Any] = {}\n    args: list[str] = []\n    if self.alias:\n        args.extend(self.alias)\n    if self.short_option:\n        args.append(self.short_option)\n    if self.default is not ...:\n        kwargs[\"help\"] = f\"{self.help} (default: {self.default})\"\n    else:\n        kwargs[\"help\"] = self.help\n    if self.type is bool and self.default is False:\n        kwargs[\"action\"] = \"store_true\"\n    parser.add_argument(\n        f\"--{self.name.replace('_', '-')}\",\n        *args,\n        metavar=self.metavar,\n        type=self.type,\n        **kwargs,\n    )\n</code></pre>"},{"location":"reference/nats_contrib/micro/cli/utils/#nats_contrib.micro.cli.utils.Flag.add_as_subcommand_option","title":"<code>add_as_subcommand_option(parser)</code>","text":"<p>Add the argument to the parser.</p> Source code in <code>src/nats_contrib/micro/cli/utils/flags.py</code> <pre><code>def add_as_subcommand_option(self, parser: argparse.ArgumentParser) -&gt; None:\n    \"\"\"Add the argument to the parser.\"\"\"\n    kwargs: dict[str, Any] = {}\n    args: list[str] = []\n    if self.alias:\n        args.extend(self.alias)\n    if self.short_option:\n        args.append(self.short_option)\n    extras: list[str] = []\n    if self.default is not ...:\n        extras.append(f\"(default: {self.default})\")\n    if self.env is not None:\n        extras.append(f\"(env: {self.env})\")\n    if extras:\n        kwargs[\"help\"] = f\"{self.help} {' '.join(extras)}\"\n    else:\n        kwargs[\"help\"] = self.help\n    if self.type is bool and self.default is False:\n        kwargs[\"action\"] = \"store_true\"\n    parser.add_argument(\n        f\"--{self.name.replace('_', '-')}\",\n        *args,\n        metavar=self.metavar,\n        type=self.type,\n        dest=f\"{self.name}_\",\n        **kwargs,\n    )\n</code></pre>"},{"location":"reference/nats_contrib/micro/cli/utils/#nats_contrib.micro.cli.utils.Flag.get","title":"<code>get(args)</code>","text":"<p>Get the value of the argument from the namespace.</p> Source code in <code>src/nats_contrib/micro/cli/utils/flags.py</code> <pre><code>def get(self, args: argparse.Namespace) -&gt; T:\n    \"\"\"Get the value of the argument from the namespace.\"\"\"\n    local = getattr(args, f\"{self.name}_\", None)\n    if local is not None:\n        return local\n    value = getattr(args, self.name, None)\n    if value is not None:\n        return value\n    if self.env is not None:\n        value = os.environ.get(self.env, None)\n        if value is not None:\n            if self.env_transform is not None:\n                return self.env_transform(value)\n            return self.type(value)\n    if self.default is not ...:\n        return self.default\n\n    raise ValueError(f\"missing argument: {self.name}\")\n</code></pre>"}]}