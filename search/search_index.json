{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"NATS Micro for Python","text":"<p>This is not an official NATS project</p> <p>This is a personal project and is not endorsed by the NATS.io community. It is not guaranteed to be maintained or supported.</p> <p>This is an experimental project</p> <p>This project is a prototype and should not be used for anything serious. It is not tested, nor is it guaranteed to be correct.</p> <p>The micro package in the NATS.go library provides a simple way to create microservices that leverage NATS for scalability, load management and observability.</p> <p>This project is an attempt to implement the same API in Python.</p>"},{"location":"#references","title":"References","text":"<ul> <li> <p>The reference document for NATS Micro is the ADR-32: Service API.</p> </li> <li> <p>The reference implementation is the Go micro package.</p> </li> <li> <p>A typescript implementation is available in nats.deno</p> </li> </ul>"},{"location":"#why-does-this-exist","title":"Why does this exist ?","text":"<ul> <li> <p>I wanted to give a try to implementing the ADR-32 in Python.</p> </li> <li> <p>Maybe this can help getting an official implementation in the NATS Python client.</p> </li> </ul>"},{"location":"#whats-lacking","title":"What's lacking ?","text":"<ul> <li>There is no test, and it may not be correct.</li> </ul>"},{"location":"#how-to-install","title":"How to install","text":"pip install git+https://github.com/charbonats/nats-micro.git"},{"location":"#api-proposal","title":"API Proposal","text":"<p>The API is inspired by the Go micro package:</p> <ul> <li>In order to use the package, you need to create a NATS connection using the nats-py package:</li> </ul> <pre><code>from nats.aio.client import Client\n\n# Somewhere in an async function\nnc = await Client().connect(\"nats://localhost:4222\")\n</code></pre> <ul> <li>Create a new service with <code>micro.add_service</code>:</li> </ul> <pre><code>from nats_contrib import micro\n\n\nservice = micro.add_service(\n    nc,\n    name=\"demo-service\",\n    version=\"1.0.0\",\n    description=\"Demo service\",\n)\n</code></pre> <ul> <li>Unlike the Go implementation, the service is not started automatically. You need to call <code>service.start</code> to start the service, or use the service as an async context manager which allows to both create and start the service in a single line:</li> </ul> <pre><code>async with micro.add_service(\n    nc,\n    name=\"demo-service\",\n    version=\"1.0.0\",\n    description=\"Demo service\",\n) as service:\n    ...\n</code></pre> <ul> <li>Once service is started, you can add endpoints to the service using <code>Service.add_endpoint</code>:</li> </ul> <pre><code>async def echo(req: micro.Request) -&gt; None:\n    \"\"\"Echo the request data back to the client.\"\"\"\n    await req.respond(req.data())\n\n\nawait service.add_endpoint(\n    name=\"echo\",\n    handler=echo,\n)\n</code></pre> <p>As defined in the ADR, an endpoint must provide at least a name and a handler. The handler is a coroutine that takes a <code>micro.Request</code> as its only argument and returns <code>None</code>.</p> <p>If no subject is provided, the endpoint will use the service name as the subject. It's possible to provide a subject with the <code>subject</code> argument:</p> <pre><code>await service.add_endpoint(\n    name=\"echo\",\n    handler=echo,\n    subject=\"ECHO\",\n)\n</code></pre> <ul> <li>You can also add groups to the service:</li> </ul> <pre><code>group = service.add_group(\"demo\")\n</code></pre> <p>As defined in the ADR, a group serves as a common prefix to all endpoints registered in it.</p> <ul> <li>You can add endpoints to a group using <code>Group.add_endpoint</code></li> </ul> <pre><code>await group.add_endpoint(\n    name=\"echo\",\n    handler=echo,\n)\n</code></pre> <p>This is equivalent to adding an endpoint to the service with the subject prefixed by the group name.</p> <ul> <li>Once you're done, you can stop the service with <code>service.stop()</code> if it was not used as an async context manager:</li> </ul> <pre><code>await service.stop()\n</code></pre> <ul> <li>You can check if the stop() method was called with <code>service.stopped</code>:</li> </ul> <pre><code>assert service.stopped\n</code></pre>"},{"location":"#code-complexity","title":"Code Complexity","text":"<p>I used scc to count line of codes and get an idea of the complexity of the project:</p> Language Files Lines Blank Comment Code Complexity Bytes Python 7 1013 107 213 693 36 33264 src/micro/api.py 450 39 135 276 21 16881 src/micro/internal.py 256 30 39 187 7 7245 src/micro/request.py 124 10 29 85 2 3826 src/micro/models.py 87 20 5 62 2 1834 src/micro/testing.py 80 7 5 68 4 3120 src/micro/__init__.py 15 1 0 14 0 332 src/micro/__about__.py 1 0 0 1 0 26 Total 7 1013 107 213 693 36 33264 <p>As of now, the project is less than 1000 lines of code, with a cyclomatic complexity of 36. The <code>api.py</code> file is the most complex but should still be easy to understand.</p>"},{"location":"#example-usage","title":"Example usage","text":"<p>This example shows how to create a simple service that echoes the request data back to the client and to run it until the application receives a SIGINT or a SIGTERM signal.</p> examples/minimal.py<pre><code>import asyncio\nimport contextlib\nimport signal\n\nfrom nats.aio.client import Client\n\nimport micro\n\n\nasync def echo(req: micro.Request) -&gt; None:\n    \"\"\"Echo the request data back to the client.\"\"\"\n    await req.respond(req.data())\n\n\nasync def main():\n    # Define an event to signal when to quit\n    quit_event = asyncio.Event()\n    # Attach signal handler to the event loop\n    loop = asyncio.get_event_loop()\n    for sig in (signal.Signals.SIGINT, signal.Signals.SIGTERM):\n        loop.add_signal_handler(sig, lambda *_: quit_event.set())\n    # Create an async exit stack\n    async with contextlib.AsyncExitStack() as stack:\n        # Create a NATS client\n        nc = Client()\n        # Connect to NATS\n        await nc.connect(\"nats://localhost:4222\")\n        # Push the client.close() method into the stack to be called on exit\n        stack.push_async_callback(nc.close)\n        # Push a new micro service into the stack to be stopped on exit\n        # The service will be stopped and drain its subscriptions before\n        # closing the connection.\n        service = await stack.enter_async_context(\n            micro.add_service(\n                nc,\n                name=\"demo-service\",\n                version=\"1.0.0\",\n                description=\"Demo service\",\n            )\n        )\n        group = service.add_group(\"demo\")\n        # Add an endpoint to the service\n        await group.add_endpoint(\n            name=\"echo\",\n            handler=echo,\n        )\n        # Wait for the quit event\n        await quit_event.wait()\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> <p>After you've cloned the repo, you can run the example above with</p> python examples/minimal.py <p>Once the service is running, you can use the <code>nats</code> CLI tool to send a request to the <code>demo.echo</code> subject:</p> nats req demo.echo \"Hello, world!\"21:14:34 Sending request on \"demo.echo\"21:14:34 Received with rtt 5.1048msHello, World! <p>You should receive the same message back from the service.</p> <p>You can also use the <code>nats</code> CLI tool to discover the service:</p> nats micro ls\u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\u2502                        All Micro Services                        \u2502\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u2502 Name         \u2502 Version \u2502 ID                       \u2502 Description  \u2502\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u2502 demo-service \u2502 1.0.0   \u2502 ec17c596d93a7f3dafce9570 \u2502 Demo service \u2502\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f <p>You can also use the <code>nats</code> CLI tool to request service stats:</p> nats micro info demo-serviceService Information        Service: demo-service (ec17c596d93a7f3dafce9570)    Description: Demo service        Version: 1.0.0Endpoints:            Name: echo            Subject: demo.echo        Queue Group: qStatistics for 1 Endpoint(s):echo Endpoint Statistics:        Requests: 0 in group q    Processing Time: 0s (average 0s)            Started: 2024-02-17 13:51:46 (51.15s ago)            Errors: 0Endpoint Specific Statistics:"},{"location":"#other-works","title":"Other works","text":"<ul> <li> <p>NATS Request Many</p> </li> <li> <p>NATS Connect Opts</p> </li> </ul>"},{"location":"LICENSE/","title":"License","text":"<p>MIT License</p> <p>Copyright (c) 2024 Guillaume Charbonnier</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"SUMMARY/","title":"SUMMARY","text":"<ul> <li>Home</li> <li>Reference</li> <li>License</li> </ul>"},{"location":"reference/nats_contrib/micro/","title":"Reference","text":""},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.Handler","title":"<code>Handler: TypeAlias = Callable[['Request'], Awaitable[None]]</code>  <code>module-attribute</code>","text":"<p>Handler is a function that processes a micro request.</p>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.Client","title":"<code>Client</code>","text":"Source code in <code>src/nats_contrib/micro/client.py</code> <pre><code>class Client:\n\n    def __init__(\n        self,\n        nc: NATS,\n        default_max_wait: float = 0.5,\n        api_prefix: str = API_PREFIX,\n    ) -&gt; None:\n        self.nc = nc\n        self.api_prefix = api_prefix\n        self.request_executor = RequestManyExecutor(nc, default_max_wait)\n\n    async def request(\n        self,\n        subject: str,\n        data: bytes | None = None,\n        headers: dict[str, str] | None = None,\n        timeout: float = 1,\n    ) -&gt; bytes:\n        \"\"\"Send a request and get the response.\"\"\"\n        response = await self.nc.request(\n            subject, data or b\"\", headers=headers, timeout=timeout\n        )\n        if response.headers:\n            error_code = response.headers.get(\"Nats-Service-Error-Code\")\n            if error_code:\n                raise ServiceError(\n                    int(error_code), response.headers.get(\"Nats-Service-Error\", \"\")\n                )\n\n        return response.data\n\n    async def ping(\n        self,\n        service: str | None = None,\n        max_wait: float | None = None,\n        max_count: int | None = None,\n        max_interval: float | None = None,\n    ) -&gt; list[PingInfo]:\n        \"\"\"Ping all the services.\"\"\"\n        subject = internal.get_internal_subject(\n            internal.ServiceVerb.PING, service, None, self.api_prefix\n        )\n        responses = await self.request_executor(\n            subject,\n            max_count=max_count,\n            max_wait=max_wait,\n            max_interval=max_interval,\n        )\n        return [PingInfo.from_response(json.loads(res.data)) for res in responses]\n\n    async def info(\n        self,\n        service: str | None = None,\n        max_wait: float | None = None,\n        max_count: int | None = None,\n        max_interval: float | None = None,\n    ) -&gt; list[ServiceInfo]:\n        \"\"\"Get all service informations.\"\"\"\n        subject = internal.get_internal_subject(\n            internal.ServiceVerb.INFO, service, None, self.api_prefix\n        )\n        responses = await self.request_executor(\n            subject,\n            max_count=max_count,\n            max_wait=max_wait,\n            max_interval=max_interval,\n        )\n        return [ServiceInfo.from_response(json.loads(res.data)) for res in responses]\n\n    async def stats(\n        self,\n        service: str | None = None,\n        max_wait: float | None = None,\n        max_count: int | None = None,\n        max_interval: float | None = None,\n    ) -&gt; list[ServiceStats]:\n        \"\"\"Get all services stats.\"\"\"\n        subject = internal.get_internal_subject(\n            internal.ServiceVerb.STATS, service, None, self.api_prefix\n        )\n        responses = await self.request_executor(\n            subject,\n            max_count=max_count,\n            max_wait=max_wait,\n            max_interval=max_interval,\n        )\n        return [ServiceStats.from_response(json.loads(res.data)) for res in responses]\n\n    def aping(\n        self,\n        service: str | None = None,\n        max_wait: float | None = None,\n        max_count: int | None = None,\n        max_interval: float | None = None,\n    ) -&gt; AsyncContextManager[AsyncIterator[PingInfo]]:\n        \"\"\"Ping all the services.\"\"\"\n        subject = internal.get_internal_subject(\n            internal.ServiceVerb.PING, service, None, self.api_prefix\n        )\n        return transform(\n            RequestManyIterator(\n                self.nc,\n                subject,\n                inbox=self.nc.new_inbox(),\n                max_count=max_count,\n                max_wait=max_wait,\n                max_interval=max_interval,\n            ),\n            lambda res: PingInfo.from_response(json.loads(res.data)),\n        )\n\n    def ainfo(\n        self,\n        service: str | None = None,\n        max_wait: float | None = None,\n        max_count: int | None = None,\n        max_interval: float | None = None,\n    ) -&gt; AsyncContextManager[AsyncIterator[ServiceInfo]]:\n        \"\"\"Get all service informations.\"\"\"\n        subject = internal.get_internal_subject(\n            internal.ServiceVerb.INFO, service, None, self.api_prefix\n        )\n        return transform(\n            RequestManyIterator(\n                self.nc,\n                subject,\n                inbox=self.nc.new_inbox(),\n                max_count=max_count,\n                max_wait=max_wait,\n                max_interval=max_interval,\n            ),\n            lambda res: ServiceInfo.from_response(json.loads(res.data)),\n        )\n\n    def astats(\n        self,\n        service: str | None = None,\n        max_wait: float | None = None,\n        max_count: int | None = None,\n        max_interval: float | None = None,\n    ) -&gt; AsyncContextManager[AsyncIterator[ServiceStats]]:\n        \"\"\"Get all services stats.\"\"\"\n        subject = internal.get_internal_subject(\n            internal.ServiceVerb.STATS, service, None, self.api_prefix\n        )\n        return transform(\n            RequestManyIterator(\n                self.nc,\n                subject,\n                inbox=self.nc.new_inbox(),\n                max_count=max_count,\n                max_wait=max_wait,\n                max_interval=max_interval,\n            ),\n            lambda res: ServiceStats.from_response(json.loads(res.data)),\n        )\n\n    def service(self, service: str) -&gt; Service:\n        \"\"\"Get a client for a single service.\"\"\"\n        return self.Service(self, service)\n\n    class Service:\n        def __init__(self, client: Client, service: str) -&gt; None:\n            self.client = client\n            self.service = service\n\n        async def ping(\n            self,\n            max_wait: float | None = None,\n            max_count: int | None = None,\n            max_interval: float | None = None,\n        ) -&gt; list[PingInfo]:\n            \"\"\"Ping all the service instances.\"\"\"\n            return await self.client.ping(\n                self.service, max_wait, max_count, max_interval\n            )\n\n        async def info(\n            self,\n            max_wait: float | None = None,\n            max_count: int | None = None,\n            max_interval: float | None = None,\n        ) -&gt; list[ServiceInfo]:\n            \"\"\"Get all service instance informations.\"\"\"\n            return await self.client.info(\n                self.service, max_wait, max_count, max_interval\n            )\n\n        async def stats(\n            self,\n            max_wait: float | None = None,\n            max_count: int | None = None,\n            max_interval: float | None = None,\n        ) -&gt; list[ServiceStats]:\n            \"\"\"Get all service instance stats.\"\"\"\n            return await self.client.stats(\n                self.service, max_wait, max_count, max_interval\n            )\n\n        def aping(\n            self,\n            max_wait: float | None = None,\n            max_count: int | None = None,\n            max_interval: float | None = None,\n        ) -&gt; AsyncContextManager[AsyncIterator[PingInfo]]:\n            \"\"\"Ping all the service instances.\"\"\"\n            return self.client.aping(self.service, max_wait, max_count, max_interval)\n\n        def ainfo(\n            self,\n            max_wait: float | None = None,\n            max_count: int | None = None,\n            max_interval: float | None = None,\n        ) -&gt; AsyncContextManager[AsyncIterator[ServiceInfo]]:\n            \"\"\"Get all service instance informations.\"\"\"\n            return self.client.ainfo(self.service, max_wait, max_count, max_interval)\n\n        def astats(\n            self,\n            max_wait: float | None = None,\n            max_count: int | None = None,\n            max_interval: float | None = None,\n        ) -&gt; AsyncContextManager[AsyncIterator[ServiceStats]]:\n            \"\"\"Get all service instance stats.\"\"\"\n            return self.client.astats(self.service, max_wait, max_count, max_interval)\n\n        def instance(self, id: str) -&gt; Client.Instance:\n            \"\"\"Get a client for a single service instance.\"\"\"\n            return Client.Instance(self.client, self.service, id)\n\n    class Instance:\n        def __init__(self, client: Client, service: str, id: str) -&gt; None:\n            self.client = client\n            self.service = service\n            self.id = id\n\n        async def ping(\n            self,\n            timeout: float = 0.5,\n        ) -&gt; PingInfo:\n            \"\"\"Ping a service instance.\"\"\"\n            subject = internal.get_internal_subject(\n                internal.ServiceVerb.PING, self.service, self.id, self.client.api_prefix\n            )\n            response = await self.client.nc.request(subject, b\"\", timeout=timeout)\n            return PingInfo.from_response(json.loads(response.data))\n\n        async def info(\n            self,\n            timeout: float = 0.5,\n        ) -&gt; ServiceInfo:\n            \"\"\"Get the service instance information.\"\"\"\n            subject = internal.get_internal_subject(\n                internal.ServiceVerb.INFO, self.service, self.id, self.client.api_prefix\n            )\n            response = await self.client.nc.request(subject, b\"\", timeout=timeout)\n            return ServiceInfo.from_response(json.loads(response.data))\n\n        async def stats(\n            self,\n            timeout: float = 0.5,\n        ) -&gt; ServiceStats:\n            \"\"\"Get the service instance stats.\"\"\"\n            subject = internal.get_internal_subject(\n                internal.ServiceVerb.STATS,\n                self.service,\n                self.id,\n                self.client.api_prefix,\n            )\n            response = await self.client.nc.request(subject, b\"\", timeout=timeout)\n            return ServiceStats.from_response(json.loads(response.data))\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.Client.Instance","title":"<code>Instance</code>","text":"Source code in <code>src/nats_contrib/micro/client.py</code> <pre><code>class Instance:\n    def __init__(self, client: Client, service: str, id: str) -&gt; None:\n        self.client = client\n        self.service = service\n        self.id = id\n\n    async def ping(\n        self,\n        timeout: float = 0.5,\n    ) -&gt; PingInfo:\n        \"\"\"Ping a service instance.\"\"\"\n        subject = internal.get_internal_subject(\n            internal.ServiceVerb.PING, self.service, self.id, self.client.api_prefix\n        )\n        response = await self.client.nc.request(subject, b\"\", timeout=timeout)\n        return PingInfo.from_response(json.loads(response.data))\n\n    async def info(\n        self,\n        timeout: float = 0.5,\n    ) -&gt; ServiceInfo:\n        \"\"\"Get the service instance information.\"\"\"\n        subject = internal.get_internal_subject(\n            internal.ServiceVerb.INFO, self.service, self.id, self.client.api_prefix\n        )\n        response = await self.client.nc.request(subject, b\"\", timeout=timeout)\n        return ServiceInfo.from_response(json.loads(response.data))\n\n    async def stats(\n        self,\n        timeout: float = 0.5,\n    ) -&gt; ServiceStats:\n        \"\"\"Get the service instance stats.\"\"\"\n        subject = internal.get_internal_subject(\n            internal.ServiceVerb.STATS,\n            self.service,\n            self.id,\n            self.client.api_prefix,\n        )\n        response = await self.client.nc.request(subject, b\"\", timeout=timeout)\n        return ServiceStats.from_response(json.loads(response.data))\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.Client.Instance.info","title":"<code>info(timeout=0.5)</code>  <code>async</code>","text":"<p>Get the service instance information.</p> Source code in <code>src/nats_contrib/micro/client.py</code> <pre><code>async def info(\n    self,\n    timeout: float = 0.5,\n) -&gt; ServiceInfo:\n    \"\"\"Get the service instance information.\"\"\"\n    subject = internal.get_internal_subject(\n        internal.ServiceVerb.INFO, self.service, self.id, self.client.api_prefix\n    )\n    response = await self.client.nc.request(subject, b\"\", timeout=timeout)\n    return ServiceInfo.from_response(json.loads(response.data))\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.Client.Instance.ping","title":"<code>ping(timeout=0.5)</code>  <code>async</code>","text":"<p>Ping a service instance.</p> Source code in <code>src/nats_contrib/micro/client.py</code> <pre><code>async def ping(\n    self,\n    timeout: float = 0.5,\n) -&gt; PingInfo:\n    \"\"\"Ping a service instance.\"\"\"\n    subject = internal.get_internal_subject(\n        internal.ServiceVerb.PING, self.service, self.id, self.client.api_prefix\n    )\n    response = await self.client.nc.request(subject, b\"\", timeout=timeout)\n    return PingInfo.from_response(json.loads(response.data))\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.Client.Instance.stats","title":"<code>stats(timeout=0.5)</code>  <code>async</code>","text":"<p>Get the service instance stats.</p> Source code in <code>src/nats_contrib/micro/client.py</code> <pre><code>async def stats(\n    self,\n    timeout: float = 0.5,\n) -&gt; ServiceStats:\n    \"\"\"Get the service instance stats.\"\"\"\n    subject = internal.get_internal_subject(\n        internal.ServiceVerb.STATS,\n        self.service,\n        self.id,\n        self.client.api_prefix,\n    )\n    response = await self.client.nc.request(subject, b\"\", timeout=timeout)\n    return ServiceStats.from_response(json.loads(response.data))\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.Client.Service","title":"<code>Service</code>","text":"Source code in <code>src/nats_contrib/micro/client.py</code> <pre><code>class Service:\n    def __init__(self, client: Client, service: str) -&gt; None:\n        self.client = client\n        self.service = service\n\n    async def ping(\n        self,\n        max_wait: float | None = None,\n        max_count: int | None = None,\n        max_interval: float | None = None,\n    ) -&gt; list[PingInfo]:\n        \"\"\"Ping all the service instances.\"\"\"\n        return await self.client.ping(\n            self.service, max_wait, max_count, max_interval\n        )\n\n    async def info(\n        self,\n        max_wait: float | None = None,\n        max_count: int | None = None,\n        max_interval: float | None = None,\n    ) -&gt; list[ServiceInfo]:\n        \"\"\"Get all service instance informations.\"\"\"\n        return await self.client.info(\n            self.service, max_wait, max_count, max_interval\n        )\n\n    async def stats(\n        self,\n        max_wait: float | None = None,\n        max_count: int | None = None,\n        max_interval: float | None = None,\n    ) -&gt; list[ServiceStats]:\n        \"\"\"Get all service instance stats.\"\"\"\n        return await self.client.stats(\n            self.service, max_wait, max_count, max_interval\n        )\n\n    def aping(\n        self,\n        max_wait: float | None = None,\n        max_count: int | None = None,\n        max_interval: float | None = None,\n    ) -&gt; AsyncContextManager[AsyncIterator[PingInfo]]:\n        \"\"\"Ping all the service instances.\"\"\"\n        return self.client.aping(self.service, max_wait, max_count, max_interval)\n\n    def ainfo(\n        self,\n        max_wait: float | None = None,\n        max_count: int | None = None,\n        max_interval: float | None = None,\n    ) -&gt; AsyncContextManager[AsyncIterator[ServiceInfo]]:\n        \"\"\"Get all service instance informations.\"\"\"\n        return self.client.ainfo(self.service, max_wait, max_count, max_interval)\n\n    def astats(\n        self,\n        max_wait: float | None = None,\n        max_count: int | None = None,\n        max_interval: float | None = None,\n    ) -&gt; AsyncContextManager[AsyncIterator[ServiceStats]]:\n        \"\"\"Get all service instance stats.\"\"\"\n        return self.client.astats(self.service, max_wait, max_count, max_interval)\n\n    def instance(self, id: str) -&gt; Client.Instance:\n        \"\"\"Get a client for a single service instance.\"\"\"\n        return Client.Instance(self.client, self.service, id)\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.Client.Service.ainfo","title":"<code>ainfo(max_wait=None, max_count=None, max_interval=None)</code>","text":"<p>Get all service instance informations.</p> Source code in <code>src/nats_contrib/micro/client.py</code> <pre><code>def ainfo(\n    self,\n    max_wait: float | None = None,\n    max_count: int | None = None,\n    max_interval: float | None = None,\n) -&gt; AsyncContextManager[AsyncIterator[ServiceInfo]]:\n    \"\"\"Get all service instance informations.\"\"\"\n    return self.client.ainfo(self.service, max_wait, max_count, max_interval)\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.Client.Service.aping","title":"<code>aping(max_wait=None, max_count=None, max_interval=None)</code>","text":"<p>Ping all the service instances.</p> Source code in <code>src/nats_contrib/micro/client.py</code> <pre><code>def aping(\n    self,\n    max_wait: float | None = None,\n    max_count: int | None = None,\n    max_interval: float | None = None,\n) -&gt; AsyncContextManager[AsyncIterator[PingInfo]]:\n    \"\"\"Ping all the service instances.\"\"\"\n    return self.client.aping(self.service, max_wait, max_count, max_interval)\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.Client.Service.astats","title":"<code>astats(max_wait=None, max_count=None, max_interval=None)</code>","text":"<p>Get all service instance stats.</p> Source code in <code>src/nats_contrib/micro/client.py</code> <pre><code>def astats(\n    self,\n    max_wait: float | None = None,\n    max_count: int | None = None,\n    max_interval: float | None = None,\n) -&gt; AsyncContextManager[AsyncIterator[ServiceStats]]:\n    \"\"\"Get all service instance stats.\"\"\"\n    return self.client.astats(self.service, max_wait, max_count, max_interval)\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.Client.Service.info","title":"<code>info(max_wait=None, max_count=None, max_interval=None)</code>  <code>async</code>","text":"<p>Get all service instance informations.</p> Source code in <code>src/nats_contrib/micro/client.py</code> <pre><code>async def info(\n    self,\n    max_wait: float | None = None,\n    max_count: int | None = None,\n    max_interval: float | None = None,\n) -&gt; list[ServiceInfo]:\n    \"\"\"Get all service instance informations.\"\"\"\n    return await self.client.info(\n        self.service, max_wait, max_count, max_interval\n    )\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.Client.Service.instance","title":"<code>instance(id)</code>","text":"<p>Get a client for a single service instance.</p> Source code in <code>src/nats_contrib/micro/client.py</code> <pre><code>def instance(self, id: str) -&gt; Client.Instance:\n    \"\"\"Get a client for a single service instance.\"\"\"\n    return Client.Instance(self.client, self.service, id)\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.Client.Service.ping","title":"<code>ping(max_wait=None, max_count=None, max_interval=None)</code>  <code>async</code>","text":"<p>Ping all the service instances.</p> Source code in <code>src/nats_contrib/micro/client.py</code> <pre><code>async def ping(\n    self,\n    max_wait: float | None = None,\n    max_count: int | None = None,\n    max_interval: float | None = None,\n) -&gt; list[PingInfo]:\n    \"\"\"Ping all the service instances.\"\"\"\n    return await self.client.ping(\n        self.service, max_wait, max_count, max_interval\n    )\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.Client.Service.stats","title":"<code>stats(max_wait=None, max_count=None, max_interval=None)</code>  <code>async</code>","text":"<p>Get all service instance stats.</p> Source code in <code>src/nats_contrib/micro/client.py</code> <pre><code>async def stats(\n    self,\n    max_wait: float | None = None,\n    max_count: int | None = None,\n    max_interval: float | None = None,\n) -&gt; list[ServiceStats]:\n    \"\"\"Get all service instance stats.\"\"\"\n    return await self.client.stats(\n        self.service, max_wait, max_count, max_interval\n    )\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.Client.ainfo","title":"<code>ainfo(service=None, max_wait=None, max_count=None, max_interval=None)</code>","text":"<p>Get all service informations.</p> Source code in <code>src/nats_contrib/micro/client.py</code> <pre><code>def ainfo(\n    self,\n    service: str | None = None,\n    max_wait: float | None = None,\n    max_count: int | None = None,\n    max_interval: float | None = None,\n) -&gt; AsyncContextManager[AsyncIterator[ServiceInfo]]:\n    \"\"\"Get all service informations.\"\"\"\n    subject = internal.get_internal_subject(\n        internal.ServiceVerb.INFO, service, None, self.api_prefix\n    )\n    return transform(\n        RequestManyIterator(\n            self.nc,\n            subject,\n            inbox=self.nc.new_inbox(),\n            max_count=max_count,\n            max_wait=max_wait,\n            max_interval=max_interval,\n        ),\n        lambda res: ServiceInfo.from_response(json.loads(res.data)),\n    )\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.Client.aping","title":"<code>aping(service=None, max_wait=None, max_count=None, max_interval=None)</code>","text":"<p>Ping all the services.</p> Source code in <code>src/nats_contrib/micro/client.py</code> <pre><code>def aping(\n    self,\n    service: str | None = None,\n    max_wait: float | None = None,\n    max_count: int | None = None,\n    max_interval: float | None = None,\n) -&gt; AsyncContextManager[AsyncIterator[PingInfo]]:\n    \"\"\"Ping all the services.\"\"\"\n    subject = internal.get_internal_subject(\n        internal.ServiceVerb.PING, service, None, self.api_prefix\n    )\n    return transform(\n        RequestManyIterator(\n            self.nc,\n            subject,\n            inbox=self.nc.new_inbox(),\n            max_count=max_count,\n            max_wait=max_wait,\n            max_interval=max_interval,\n        ),\n        lambda res: PingInfo.from_response(json.loads(res.data)),\n    )\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.Client.astats","title":"<code>astats(service=None, max_wait=None, max_count=None, max_interval=None)</code>","text":"<p>Get all services stats.</p> Source code in <code>src/nats_contrib/micro/client.py</code> <pre><code>def astats(\n    self,\n    service: str | None = None,\n    max_wait: float | None = None,\n    max_count: int | None = None,\n    max_interval: float | None = None,\n) -&gt; AsyncContextManager[AsyncIterator[ServiceStats]]:\n    \"\"\"Get all services stats.\"\"\"\n    subject = internal.get_internal_subject(\n        internal.ServiceVerb.STATS, service, None, self.api_prefix\n    )\n    return transform(\n        RequestManyIterator(\n            self.nc,\n            subject,\n            inbox=self.nc.new_inbox(),\n            max_count=max_count,\n            max_wait=max_wait,\n            max_interval=max_interval,\n        ),\n        lambda res: ServiceStats.from_response(json.loads(res.data)),\n    )\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.Client.info","title":"<code>info(service=None, max_wait=None, max_count=None, max_interval=None)</code>  <code>async</code>","text":"<p>Get all service informations.</p> Source code in <code>src/nats_contrib/micro/client.py</code> <pre><code>async def info(\n    self,\n    service: str | None = None,\n    max_wait: float | None = None,\n    max_count: int | None = None,\n    max_interval: float | None = None,\n) -&gt; list[ServiceInfo]:\n    \"\"\"Get all service informations.\"\"\"\n    subject = internal.get_internal_subject(\n        internal.ServiceVerb.INFO, service, None, self.api_prefix\n    )\n    responses = await self.request_executor(\n        subject,\n        max_count=max_count,\n        max_wait=max_wait,\n        max_interval=max_interval,\n    )\n    return [ServiceInfo.from_response(json.loads(res.data)) for res in responses]\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.Client.ping","title":"<code>ping(service=None, max_wait=None, max_count=None, max_interval=None)</code>  <code>async</code>","text":"<p>Ping all the services.</p> Source code in <code>src/nats_contrib/micro/client.py</code> <pre><code>async def ping(\n    self,\n    service: str | None = None,\n    max_wait: float | None = None,\n    max_count: int | None = None,\n    max_interval: float | None = None,\n) -&gt; list[PingInfo]:\n    \"\"\"Ping all the services.\"\"\"\n    subject = internal.get_internal_subject(\n        internal.ServiceVerb.PING, service, None, self.api_prefix\n    )\n    responses = await self.request_executor(\n        subject,\n        max_count=max_count,\n        max_wait=max_wait,\n        max_interval=max_interval,\n    )\n    return [PingInfo.from_response(json.loads(res.data)) for res in responses]\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.Client.request","title":"<code>request(subject, data=None, headers=None, timeout=1)</code>  <code>async</code>","text":"<p>Send a request and get the response.</p> Source code in <code>src/nats_contrib/micro/client.py</code> <pre><code>async def request(\n    self,\n    subject: str,\n    data: bytes | None = None,\n    headers: dict[str, str] | None = None,\n    timeout: float = 1,\n) -&gt; bytes:\n    \"\"\"Send a request and get the response.\"\"\"\n    response = await self.nc.request(\n        subject, data or b\"\", headers=headers, timeout=timeout\n    )\n    if response.headers:\n        error_code = response.headers.get(\"Nats-Service-Error-Code\")\n        if error_code:\n            raise ServiceError(\n                int(error_code), response.headers.get(\"Nats-Service-Error\", \"\")\n            )\n\n    return response.data\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.Client.service","title":"<code>service(service)</code>","text":"<p>Get a client for a single service.</p> Source code in <code>src/nats_contrib/micro/client.py</code> <pre><code>def service(self, service: str) -&gt; Service:\n    \"\"\"Get a client for a single service.\"\"\"\n    return self.Service(self, service)\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.Client.stats","title":"<code>stats(service=None, max_wait=None, max_count=None, max_interval=None)</code>  <code>async</code>","text":"<p>Get all services stats.</p> Source code in <code>src/nats_contrib/micro/client.py</code> <pre><code>async def stats(\n    self,\n    service: str | None = None,\n    max_wait: float | None = None,\n    max_count: int | None = None,\n    max_interval: float | None = None,\n) -&gt; list[ServiceStats]:\n    \"\"\"Get all services stats.\"\"\"\n    subject = internal.get_internal_subject(\n        internal.ServiceVerb.STATS, service, None, self.api_prefix\n    )\n    responses = await self.request_executor(\n        subject,\n        max_count=max_count,\n        max_wait=max_wait,\n        max_interval=max_interval,\n    )\n    return [ServiceStats.from_response(json.loads(res.data)) for res in responses]\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.Endpoint","title":"<code>Endpoint</code>","text":"<p>Endpoint manages a service endpoint.</p> Source code in <code>src/nats_contrib/micro/api.py</code> <pre><code>class Endpoint:\n    \"\"\"Endpoint manages a service endpoint.\"\"\"\n\n    def __init__(self, config: internal.EndpointConfig) -&gt; None:\n        self.config = config\n        self.stats = internal.create_endpoint_stats(config)\n        self.info = internal.create_endpoint_info(config)\n        self._sub: Subscription | None = None\n\n    def reset(self) -&gt; None:\n        \"\"\"Reset the endpoint statistics.\"\"\"\n        self.stats = internal.create_endpoint_stats(self.config)\n        self.info = internal.create_endpoint_info(self.config)\n\n    async def stop(self) -&gt; None:\n        \"\"\"Stop the endpoint by draining its subscription.\"\"\"\n        if self._sub:\n            await unsubscribe(self._sub)\n            self._sub = None\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.Endpoint.reset","title":"<code>reset()</code>","text":"<p>Reset the endpoint statistics.</p> Source code in <code>src/nats_contrib/micro/api.py</code> <pre><code>def reset(self) -&gt; None:\n    \"\"\"Reset the endpoint statistics.\"\"\"\n    self.stats = internal.create_endpoint_stats(self.config)\n    self.info = internal.create_endpoint_info(self.config)\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.Endpoint.stop","title":"<code>stop()</code>  <code>async</code>","text":"<p>Stop the endpoint by draining its subscription.</p> Source code in <code>src/nats_contrib/micro/api.py</code> <pre><code>async def stop(self) -&gt; None:\n    \"\"\"Stop the endpoint by draining its subscription.\"\"\"\n    if self._sub:\n        await unsubscribe(self._sub)\n        self._sub = None\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.EndpointInfo","title":"<code>EndpointInfo</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Base</code></p> <p>The information of an endpoint.</p> Source code in <code>src/nats_contrib/micro/models.py</code> <pre><code>@dataclass\nclass EndpointInfo(Base):\n    \"\"\"The information of an endpoint.\"\"\"\n\n    name: str\n    \"\"\"\n    The endopoint name\n    \"\"\"\n    subject: str\n    \"\"\"\n    The subject the endpoint listens on\n    \"\"\"\n    metadata: dict[str, str] | None = None\n    \"\"\"\n    The endpoint metadata.\n    \"\"\"\n    queue_group: str | None = None\n    \"\"\"\n    The queue group this endpoint listens on for requests\n    \"\"\"\n\n    def copy(self) -&gt; EndpointInfo:\n        return replace(\n            self,\n            metadata=None if self.metadata is None else self.metadata.copy(),\n        )\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.EndpointInfo.metadata","title":"<code>metadata: dict[str, str] | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The endpoint metadata.</p>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.EndpointInfo.name","title":"<code>name: str</code>  <code>instance-attribute</code>","text":"<p>The endopoint name</p>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.EndpointInfo.queue_group","title":"<code>queue_group: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The queue group this endpoint listens on for requests</p>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.EndpointInfo.subject","title":"<code>subject: str</code>  <code>instance-attribute</code>","text":"<p>The subject the endpoint listens on</p>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.EndpointStats","title":"<code>EndpointStats</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Base</code></p> <p>Statistics about a specific service endpoint</p> Source code in <code>src/nats_contrib/micro/models.py</code> <pre><code>@dataclass\nclass EndpointStats(Base):\n    \"\"\"\n    Statistics about a specific service endpoint\n    \"\"\"\n\n    name: str\n    \"\"\"\n    The endpoint name\n    \"\"\"\n    subject: str\n    \"\"\"\n    The subject the endpoint listens on\n    \"\"\"\n    num_requests: int\n    \"\"\"\n    The number of requests this endpoint received\n    \"\"\"\n    num_errors: int\n    \"\"\"\n    The number of errors this endpoint encountered\n    \"\"\"\n    last_error: str\n    \"\"\"\n    The last error the service encountered\n    \"\"\"\n    processing_time: int\n    \"\"\"\n    How long, in total, was spent processing requests in the handler\n    \"\"\"\n    average_processing_time: int\n    \"\"\"\n    The average time spent processing requests\n    \"\"\"\n    queue_group: str | None = None\n    \"\"\"\n    The queue group this endpoint listens on for requests\n    \"\"\"\n    data: dict[str, object] | None = None\n    \"\"\"\n    Additional statistics the endpoint makes available\n    \"\"\"\n\n    def copy(self) -&gt; EndpointStats:\n        return replace(self, data=None if self.data is None else self.data.copy())\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.EndpointStats.average_processing_time","title":"<code>average_processing_time: int</code>  <code>instance-attribute</code>","text":"<p>The average time spent processing requests</p>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.EndpointStats.data","title":"<code>data: dict[str, object] | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Additional statistics the endpoint makes available</p>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.EndpointStats.last_error","title":"<code>last_error: str</code>  <code>instance-attribute</code>","text":"<p>The last error the service encountered</p>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.EndpointStats.name","title":"<code>name: str</code>  <code>instance-attribute</code>","text":"<p>The endpoint name</p>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.EndpointStats.num_errors","title":"<code>num_errors: int</code>  <code>instance-attribute</code>","text":"<p>The number of errors this endpoint encountered</p>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.EndpointStats.num_requests","title":"<code>num_requests: int</code>  <code>instance-attribute</code>","text":"<p>The number of requests this endpoint received</p>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.EndpointStats.processing_time","title":"<code>processing_time: int</code>  <code>instance-attribute</code>","text":"<p>How long, in total, was spent processing requests in the handler</p>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.EndpointStats.queue_group","title":"<code>queue_group: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The queue group this endpoint listens on for requests</p>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.EndpointStats.subject","title":"<code>subject: str</code>  <code>instance-attribute</code>","text":"<p>The subject the endpoint listens on</p>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.Group","title":"<code>Group</code>","text":"<p>Group allows for grouping endpoints on a service.</p> <p>Endpoints created using <code>Group.add_endpoint</code> will be grouped under common prefix (group name). New groups can also be derived from a group using <code>Group.add_group</code>.</p> Source code in <code>src/nats_contrib/micro/api.py</code> <pre><code>class Group:\n    \"\"\"Group allows for grouping endpoints on a service.\n\n    Endpoints created using `Group.add_endpoint` will be grouped\n    under common prefix (group name). New groups can also be derived\n    from a group using `Group.add_group`.\n    \"\"\"\n\n    def __init__(self, config: internal.GroupConfig, service: Service) -&gt; None:\n        self._config = config\n        self._service = service\n\n    def add_group(\n        self,\n        name: str,\n        queue_group: str | None = None,\n        pending_bytes_limit: int | None = None,\n        pending_msgs_limit: int | None = None,\n    ) -&gt; Group:\n        \"\"\"Add a group to the group.\n\n        Args:\n            name: The name of the group. Must be a valid NATS subject prefix.\n            queue_group: The default queue group of the group. When queue group is not set, it defaults to the queue group of the parent group or service.\n            pending_bytes_limit: The default pending bytes limit for each endpoint within the group.\n            pending_msgs_limit: The default pending messages limit for each endpoint within the group.\n        \"\"\"\n        config = self._config.child(\n            name=name,\n            queue_group=queue_group,\n            pending_bytes_limit=pending_bytes_limit,\n            pending_msgs_limit=pending_msgs_limit,\n        )\n        group = Group(config, self._service)\n        return group\n\n    async def add_endpoint(\n        self,\n        name: str,\n        handler: Handler,\n        subject: str | None = None,\n        queue_group: str | None = None,\n        metadata: dict[str, str] | None = None,\n        pending_bytes_limit: int | None = None,\n        pending_msgs_limit: int | None = None,\n    ) -&gt; Endpoint:\n        \"\"\"Add an endpoint to the group.\n\n        Args:\n            name: The name of the endpoint.\n            handler: The handler of the endpoint.\n            subject: The subject of the endpoint. When subject is not set, it defaults to the name of the endpoint.\n            queue_group: The queue group of the endpoint. When queue group is not set, it defaults to the queue group of the parent group or service.\n            metadata: The metadata of the endpoint.\n            pending_bytes_limit: The pending bytes limit for this endpoint.\n            pending_msgs_limit: The pending messages limit for this endpoint.\n        \"\"\"\n        return await self._service.add_endpoint(\n            name=name,\n            subject=f\"{self._config.name}.{subject or name}\",\n            handler=handler,\n            metadata=metadata,\n            queue_group=queue_group or self._config.queue_group,\n            pending_bytes_limit=pending_bytes_limit\n            or self._config.pending_bytes_limit_by_endpoint,\n            pending_msgs_limit=pending_msgs_limit\n            or self._config.pending_msgs_limit_by_endpoint,\n        )\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.Group.add_endpoint","title":"<code>add_endpoint(name, handler, subject=None, queue_group=None, metadata=None, pending_bytes_limit=None, pending_msgs_limit=None)</code>  <code>async</code>","text":"<p>Add an endpoint to the group.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the endpoint.</p> required <code>handler</code> <code>Handler</code> <p>The handler of the endpoint.</p> required <code>subject</code> <code>str | None</code> <p>The subject of the endpoint. When subject is not set, it defaults to the name of the endpoint.</p> <code>None</code> <code>queue_group</code> <code>str | None</code> <p>The queue group of the endpoint. When queue group is not set, it defaults to the queue group of the parent group or service.</p> <code>None</code> <code>metadata</code> <code>dict[str, str] | None</code> <p>The metadata of the endpoint.</p> <code>None</code> <code>pending_bytes_limit</code> <code>int | None</code> <p>The pending bytes limit for this endpoint.</p> <code>None</code> <code>pending_msgs_limit</code> <code>int | None</code> <p>The pending messages limit for this endpoint.</p> <code>None</code> Source code in <code>src/nats_contrib/micro/api.py</code> <pre><code>async def add_endpoint(\n    self,\n    name: str,\n    handler: Handler,\n    subject: str | None = None,\n    queue_group: str | None = None,\n    metadata: dict[str, str] | None = None,\n    pending_bytes_limit: int | None = None,\n    pending_msgs_limit: int | None = None,\n) -&gt; Endpoint:\n    \"\"\"Add an endpoint to the group.\n\n    Args:\n        name: The name of the endpoint.\n        handler: The handler of the endpoint.\n        subject: The subject of the endpoint. When subject is not set, it defaults to the name of the endpoint.\n        queue_group: The queue group of the endpoint. When queue group is not set, it defaults to the queue group of the parent group or service.\n        metadata: The metadata of the endpoint.\n        pending_bytes_limit: The pending bytes limit for this endpoint.\n        pending_msgs_limit: The pending messages limit for this endpoint.\n    \"\"\"\n    return await self._service.add_endpoint(\n        name=name,\n        subject=f\"{self._config.name}.{subject or name}\",\n        handler=handler,\n        metadata=metadata,\n        queue_group=queue_group or self._config.queue_group,\n        pending_bytes_limit=pending_bytes_limit\n        or self._config.pending_bytes_limit_by_endpoint,\n        pending_msgs_limit=pending_msgs_limit\n        or self._config.pending_msgs_limit_by_endpoint,\n    )\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.Group.add_group","title":"<code>add_group(name, queue_group=None, pending_bytes_limit=None, pending_msgs_limit=None)</code>","text":"<p>Add a group to the group.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the group. Must be a valid NATS subject prefix.</p> required <code>queue_group</code> <code>str | None</code> <p>The default queue group of the group. When queue group is not set, it defaults to the queue group of the parent group or service.</p> <code>None</code> <code>pending_bytes_limit</code> <code>int | None</code> <p>The default pending bytes limit for each endpoint within the group.</p> <code>None</code> <code>pending_msgs_limit</code> <code>int | None</code> <p>The default pending messages limit for each endpoint within the group.</p> <code>None</code> Source code in <code>src/nats_contrib/micro/api.py</code> <pre><code>def add_group(\n    self,\n    name: str,\n    queue_group: str | None = None,\n    pending_bytes_limit: int | None = None,\n    pending_msgs_limit: int | None = None,\n) -&gt; Group:\n    \"\"\"Add a group to the group.\n\n    Args:\n        name: The name of the group. Must be a valid NATS subject prefix.\n        queue_group: The default queue group of the group. When queue group is not set, it defaults to the queue group of the parent group or service.\n        pending_bytes_limit: The default pending bytes limit for each endpoint within the group.\n        pending_msgs_limit: The default pending messages limit for each endpoint within the group.\n    \"\"\"\n    config = self._config.child(\n        name=name,\n        queue_group=queue_group,\n        pending_bytes_limit=pending_bytes_limit,\n        pending_msgs_limit=pending_msgs_limit,\n    )\n    group = Group(config, self._service)\n    return group\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.PingInfo","title":"<code>PingInfo</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Base</code></p> <p>The response to a ping message.</p> Source code in <code>src/nats_contrib/micro/models.py</code> <pre><code>@dataclass\nclass PingInfo(Base):\n    \"\"\"The response to a ping message.\"\"\"\n\n    name: str\n    id: str\n    version: str\n    metadata: dict[str, str]\n    type: str = \"io.nats.micro.v1.ping_response\"\n\n    def copy(self) -&gt; PingInfo:\n        return replace(self, metadata=self.metadata.copy())\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.Request","title":"<code>Request</code>","text":"<p>Request is the interface for a request received by a service.</p> <p>An interface is used instead of a class to allow for different implementations. It makes it easy to test a service by using a stub implementation of Request.</p> <p>Four methods must be implemented:</p> <ul> <li><code>def subject() -&gt; str</code>: the subject on which the request was received.</li> <li><code>def headers() -&gt; dict[str, str]</code>: the headers of the request.</li> <li><code>def data() -&gt; bytes</code>: the data of the request.</li> <li><code>async def respond(...) -&gt; None</code>: send a response to the request.</li> </ul> Source code in <code>src/nats_contrib/micro/request.py</code> <pre><code>class Request(metaclass=abc.ABCMeta):\n    \"\"\"Request is the interface for a request received by a service.\n\n    An interface is used instead of a class to allow for different implementations.\n    It makes it easy to test a service by using a stub implementation of Request.\n\n    Four methods must be implemented:\n\n    - `def subject() -&gt; str`: the subject on which the request was received.\n    - `def headers() -&gt; dict[str, str]`: the headers of the request.\n    - `def data() -&gt; bytes`: the data of the request.\n    - `async def respond(...) -&gt; None`: send a response to the request.\n    \"\"\"\n\n    @abc.abstractmethod\n    def subject(self) -&gt; str:\n        \"\"\"The subject on which request was received.\"\"\"\n        raise NotImplementedError()\n\n    @abc.abstractmethod\n    def headers(self) -&gt; dict[str, str]:\n        \"\"\"The headers of the request.\"\"\"\n        raise NotImplementedError()\n\n    @abc.abstractmethod\n    def data(self) -&gt; bytes:\n        \"\"\"The data of the request.\"\"\"\n        raise NotImplementedError()\n\n    @abc.abstractmethod\n    async def respond(self, data: bytes, headers: dict[str, str] | None = None) -&gt; None:\n        \"\"\"Send a success response to the request.\n\n        Args:\n            data: The response data.\n            headers: Additional response headers.\n        \"\"\"\n        raise NotImplementedError()\n\n    async def respond_success(\n        self,\n        code: int,\n        data: bytes | None = None,\n        headers: dict[str, str] | None = None,\n    ) -&gt; None:\n        \"\"\"Send a success response to the request.\n\n        Args:\n            code: The status code describing the success.\n            data: The response data.\n            headers: Additional response headers.\n        \"\"\"\n        if not headers:\n            headers = {}\n        headers[\"Nats-Service-Success-Code\"] = str(code)\n        await self.respond(data or b\"\", headers=headers)\n\n    async def respond_error(\n        self,\n        code: int,\n        description: str,\n        data: bytes | None = None,\n        headers: dict[str, str] | None = None,\n    ) -&gt; None:\n        \"\"\"Send an error response to the request.\n\n        Args:\n            code: The error code describing the error.\n            description: A string describing the error which can be displayed to the client.\n            data: The error data.\n            headers: Additional response headers.\n        \"\"\"\n        if not headers:\n            headers = {}\n        headers[\"Nats-Service-Error\"] = description\n        headers[\"Nats-Service-Error-Code\"] = str(code)\n        await self.respond(data or b\"\", headers=headers)\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.Request.data","title":"<code>data()</code>  <code>abstractmethod</code>","text":"<p>The data of the request.</p> Source code in <code>src/nats_contrib/micro/request.py</code> <pre><code>@abc.abstractmethod\ndef data(self) -&gt; bytes:\n    \"\"\"The data of the request.\"\"\"\n    raise NotImplementedError()\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.Request.headers","title":"<code>headers()</code>  <code>abstractmethod</code>","text":"<p>The headers of the request.</p> Source code in <code>src/nats_contrib/micro/request.py</code> <pre><code>@abc.abstractmethod\ndef headers(self) -&gt; dict[str, str]:\n    \"\"\"The headers of the request.\"\"\"\n    raise NotImplementedError()\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.Request.respond","title":"<code>respond(data, headers=None)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Send a success response to the request.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>bytes</code> <p>The response data.</p> required <code>headers</code> <code>dict[str, str] | None</code> <p>Additional response headers.</p> <code>None</code> Source code in <code>src/nats_contrib/micro/request.py</code> <pre><code>@abc.abstractmethod\nasync def respond(self, data: bytes, headers: dict[str, str] | None = None) -&gt; None:\n    \"\"\"Send a success response to the request.\n\n    Args:\n        data: The response data.\n        headers: Additional response headers.\n    \"\"\"\n    raise NotImplementedError()\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.Request.respond_error","title":"<code>respond_error(code, description, data=None, headers=None)</code>  <code>async</code>","text":"<p>Send an error response to the request.</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>int</code> <p>The error code describing the error.</p> required <code>description</code> <code>str</code> <p>A string describing the error which can be displayed to the client.</p> required <code>data</code> <code>bytes | None</code> <p>The error data.</p> <code>None</code> <code>headers</code> <code>dict[str, str] | None</code> <p>Additional response headers.</p> <code>None</code> Source code in <code>src/nats_contrib/micro/request.py</code> <pre><code>async def respond_error(\n    self,\n    code: int,\n    description: str,\n    data: bytes | None = None,\n    headers: dict[str, str] | None = None,\n) -&gt; None:\n    \"\"\"Send an error response to the request.\n\n    Args:\n        code: The error code describing the error.\n        description: A string describing the error which can be displayed to the client.\n        data: The error data.\n        headers: Additional response headers.\n    \"\"\"\n    if not headers:\n        headers = {}\n    headers[\"Nats-Service-Error\"] = description\n    headers[\"Nats-Service-Error-Code\"] = str(code)\n    await self.respond(data or b\"\", headers=headers)\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.Request.respond_success","title":"<code>respond_success(code, data=None, headers=None)</code>  <code>async</code>","text":"<p>Send a success response to the request.</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>int</code> <p>The status code describing the success.</p> required <code>data</code> <code>bytes | None</code> <p>The response data.</p> <code>None</code> <code>headers</code> <code>dict[str, str] | None</code> <p>Additional response headers.</p> <code>None</code> Source code in <code>src/nats_contrib/micro/request.py</code> <pre><code>async def respond_success(\n    self,\n    code: int,\n    data: bytes | None = None,\n    headers: dict[str, str] | None = None,\n) -&gt; None:\n    \"\"\"Send a success response to the request.\n\n    Args:\n        code: The status code describing the success.\n        data: The response data.\n        headers: Additional response headers.\n    \"\"\"\n    if not headers:\n        headers = {}\n    headers[\"Nats-Service-Success-Code\"] = str(code)\n    await self.respond(data or b\"\", headers=headers)\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.Request.subject","title":"<code>subject()</code>  <code>abstractmethod</code>","text":"<p>The subject on which request was received.</p> Source code in <code>src/nats_contrib/micro/request.py</code> <pre><code>@abc.abstractmethod\ndef subject(self) -&gt; str:\n    \"\"\"The subject on which request was received.\"\"\"\n    raise NotImplementedError()\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.Service","title":"<code>Service</code>","text":"<p>Services simplify the development of NATS micro-services.</p> <p>Endpoints can be added to a service after it has been created and started. Each endpoint is a request-reply handler for a subject.</p> <p>Groups can be added to a service to group endpoints under a common prefix.</p> Source code in <code>src/nats_contrib/micro/api.py</code> <pre><code>class Service:\n    \"\"\"Services simplify the development of NATS micro-services.\n\n    Endpoints can be added to a service after it has been created and started.\n    Each endpoint is a request-reply handler for a subject.\n\n    Groups can be added to a service to group endpoints under a common prefix.\n    \"\"\"\n\n    def __init__(\n        self,\n        nc: NatsClient,\n        id: str,\n        config: internal.ServiceConfig,\n        api_prefix: str,\n        clock: Callable[[], datetime],\n    ) -&gt; None:\n        self._nc = nc\n        self._config = config\n        self._api_prefix = api_prefix\n        self._clock = clock\n        # Initialize state\n        self._id = id\n        self._endpoints: list[Endpoint] = []\n        self._stopped = False\n        # Internal responses\n        self._stats = internal.new_service_stats(self._id, self._clock(), config)\n        self._info = internal.new_service_info(self._id, config)\n        self._ping_response = internal.new_ping_info(self._id, config)\n        # Cache the serialized ping response\n        self._ping_response_message = dumps(asdict(self._ping_response)).encode()\n        # Internal subscriptions\n        self._ping_subscriptions: list[Subscription] = []\n        self._info_subscriptions: list[Subscription] = []\n        self._stats_subscriptions: list[Subscription] = []\n\n    async def start(self) -&gt; None:\n        \"\"\"Start the service.\n\n        A service MUST be started before adding endpoints.\n\n        This will start the internal subscriptions and enable\n        service discovery.\n        \"\"\"\n        # Start PING subscriptions:\n        # - $SRV.PING\n        # - $SRV.{name}.PING\n        # - $SRV.{name}.{id}.PING\n        for subject in internal.get_internal_subjects(\n            internal.ServiceVerb.PING,\n            self._id,\n            self._config,\n            api_prefix=self._api_prefix,\n        ):\n            sub = await self._nc.subscribe(  # pyright: ignore[reportUnknownMemberType]\n                subject,\n                cb=self._handle_ping_request,\n            )\n            self._ping_subscriptions.append(sub)\n        # Start INFO subscriptions:\n        # - $SRV.INFO\n        # - $SRV.{name}.INFO\n        # - $SRV.{name}.{id}.INFO\n        for subject in internal.get_internal_subjects(\n            internal.ServiceVerb.INFO,\n            self._id,\n            self._config,\n            api_prefix=self._api_prefix,\n        ):\n            sub = await self._nc.subscribe(  # pyright: ignore[reportUnknownMemberType]\n                subject,\n                cb=self._handle_info_request,\n            )\n            self._info_subscriptions.append(sub)\n        # Start STATS subscriptions:\n        # - $SRV.STATS\n        # - $SRV.{name}.STATS\n        # - $SRV.{name}.{id}.STATS\n        for subject in internal.get_internal_subjects(\n            internal.ServiceVerb.STATS,\n            self._id,\n            self._config,\n            api_prefix=self._api_prefix,\n        ):\n            sub = await self._nc.subscribe(  # pyright: ignore[reportUnknownMemberType]\n                subject,\n                cb=self._handle_stats_request,\n            )\n            self._stats_subscriptions.append(sub)\n\n    async def stop(self) -&gt; None:\n        \"\"\"Stop the service.\n\n        This will stop all endpoints and internal subscriptions.\n        \"\"\"\n        self._stopped = True\n        # Stop all endpoints\n        await asyncio.gather(*(ep.stop() for ep in self._endpoints))\n        # Stop all internal subscriptions\n        await asyncio.gather(\n            *(\n                unsubscribe(sub)\n                for subscriptions in (\n                    self._stats_subscriptions,\n                    self._info_subscriptions,\n                    self._ping_subscriptions,\n                )\n                for sub in subscriptions\n            )\n        )\n\n    def stopped(self) -&gt; bool:\n        \"\"\"Stopped informs whether [Stop] was executed on the service.\"\"\"\n        return self._stopped\n\n    def info(self) -&gt; ServiceInfo:\n        \"\"\"Returns the service info.\"\"\"\n        return self._info.copy()\n\n    def stats(self) -&gt; ServiceStats:\n        \"\"\"Returns statistics for the service endpoint and all monitoring endpoints.\"\"\"\n        return self._stats.copy()\n\n    def reset(self) -&gt; None:\n        \"\"\"Resets all statistics (for all endpoints) on a service instance.\"\"\"\n\n        # Internal responses\n        self._stats = internal.new_service_stats(self._id, self._clock(), self._config)\n        self._info = internal.new_service_info(self._id, self._config)\n        self._ping_response = internal.new_ping_info(self._id, self._config)\n        self._ping_response_message = internal.encode_ping_info(self._ping_response)\n        # Reset all endpoints\n        endpoints = list(self._endpoints)\n        self._endpoints.clear()\n        for ep in endpoints:\n            ep.reset()\n            self._endpoints.append(ep)\n            self._stats.endpoints.append(ep.stats)\n            self._info.endpoints.append(ep.info)\n\n    def add_group(\n        self,\n        name: str,\n        queue_group: str | None = None,\n        pending_bytes_limit_by_endpoint: int | None = None,\n        pending_msgs_limit_by_endpoint: int | None = None,\n    ) -&gt; Group:\n        \"\"\"Add a group to the service.\n\n        A group is a collection of endpoints that share the same prefix,\n        and the same default queue group and pending limits.\n\n        At runtime, a group does not exist as a separate entity, only\n        endpoints exist. However, groups are useful to organize endpoints\n        and to set default values for queue group and pending limits.\n\n        Args:\n            name: The name of the group.\n            queue_group: The default queue group of the group. When queue group is not set, it defaults to the queue group of the parent group or service.\n            pending_bytes_limit_by_endpoint: The default pending bytes limit for each endpoint within the group.\n            pending_msgs_limit_by_endpoint: The default pending messages limit for each endpoint within the group.\n        \"\"\"\n        config = internal.GroupConfig(\n            name=name,\n            queue_group=queue_group or self._config.queue_group,\n            pending_bytes_limit_by_endpoint=pending_bytes_limit_by_endpoint\n            or self._config.pending_bytes_limit_by_endpoint,\n            pending_msgs_limit_by_endpoint=pending_msgs_limit_by_endpoint\n            or self._config.pending_msgs_limit_by_endpoint,\n        )\n        return Group(config, self)\n\n    async def add_endpoint(\n        self,\n        name: str,\n        handler: Handler,\n        subject: str | None = None,\n        queue_group: str | None = None,\n        metadata: dict[str, str] | None = None,\n        pending_bytes_limit: int | None = None,\n        pending_msgs_limit: int | None = None,\n    ) -&gt; Endpoint:\n        \"\"\"Add an endpoint to the service.\n\n        An endpoint is a request-reply handler for a subject.\n\n        Args:\n            name: The name of the endpoint.\n            handler: The handler of the endpoint.\n            subject: The subject of the endpoint. When subject is not set, it defaults to the name of the endpoint.\n            queue_group: The queue group of the endpoint. When queue group is not set, it defaults to the queue group of the parent group or service.\n            metadata: The metadata of the endpoint.\n            pending_bytes_limit: The pending bytes limit for this endpoint.\n            pending_msgs_limit: The pending messages limit for this endpoint.\n        \"\"\"\n        if self._stopped:\n            raise RuntimeError(\"Cannot add endpoint to a stopped service\")\n        config = self._config.endpoint_config(\n            name=name,\n            handler=handler,\n            subject=subject,\n            queue_group=queue_group,\n            metadata=metadata,\n            pending_bytes_limit=pending_bytes_limit,\n            pending_msgs_limit=pending_msgs_limit,\n        )\n        # Create the endpoint\n        ep = Endpoint(config)\n        # Create the endpoint handler\n        subscription_handler = _create_handler(ep)\n        # Start the endpoint subscription\n        subscription = (\n            await self._nc.subscribe(  # pyright: ignore[reportUnknownMemberType]\n                config.subject,\n                queue=config.queue_group,\n                cb=subscription_handler,\n            )\n        )\n        # Attach the subscription to the endpoint\n        ep._sub = subscription  # pyright: ignore[reportPrivateUsage]\n        # Append the endpoint to the service\n        self._endpoints.append(ep)\n        # Append the endpoint to the service stats and info\n        self._stats.endpoints.append(ep.stats)\n        self._info.endpoints.append(ep.info)\n        return ep\n\n    async def _handle_ping_request(self, msg: Msg) -&gt; None:\n        \"\"\"Handle the ping message.\"\"\"\n        await msg.respond(data=self._ping_response_message)\n\n    async def _handle_info_request(self, msg: Msg) -&gt; None:\n        \"\"\"Handle the info message.\"\"\"\n        await msg.respond(data=internal.encode_info(self._info))\n\n    async def _handle_stats_request(self, msg: Msg) -&gt; None:\n        \"\"\"Handle the stats message.\"\"\"\n        await msg.respond(data=internal.encode_stats(self._stats))\n\n    async def __aenter__(self) -&gt; Service:\n        \"\"\"Implement the asynchronous context manager interface.\"\"\"\n        await self.start()\n        return self\n\n    async def __aexit__(self, *args: object, **kwargs: object) -&gt; None:\n        \"\"\"Implement the asynchronous context manager interface.\"\"\"\n        await self.stop()\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.Service.__aenter__","title":"<code>__aenter__()</code>  <code>async</code>","text":"<p>Implement the asynchronous context manager interface.</p> Source code in <code>src/nats_contrib/micro/api.py</code> <pre><code>async def __aenter__(self) -&gt; Service:\n    \"\"\"Implement the asynchronous context manager interface.\"\"\"\n    await self.start()\n    return self\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.Service.__aexit__","title":"<code>__aexit__(*args, **kwargs)</code>  <code>async</code>","text":"<p>Implement the asynchronous context manager interface.</p> Source code in <code>src/nats_contrib/micro/api.py</code> <pre><code>async def __aexit__(self, *args: object, **kwargs: object) -&gt; None:\n    \"\"\"Implement the asynchronous context manager interface.\"\"\"\n    await self.stop()\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.Service.add_endpoint","title":"<code>add_endpoint(name, handler, subject=None, queue_group=None, metadata=None, pending_bytes_limit=None, pending_msgs_limit=None)</code>  <code>async</code>","text":"<p>Add an endpoint to the service.</p> <p>An endpoint is a request-reply handler for a subject.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the endpoint.</p> required <code>handler</code> <code>Handler</code> <p>The handler of the endpoint.</p> required <code>subject</code> <code>str | None</code> <p>The subject of the endpoint. When subject is not set, it defaults to the name of the endpoint.</p> <code>None</code> <code>queue_group</code> <code>str | None</code> <p>The queue group of the endpoint. When queue group is not set, it defaults to the queue group of the parent group or service.</p> <code>None</code> <code>metadata</code> <code>dict[str, str] | None</code> <p>The metadata of the endpoint.</p> <code>None</code> <code>pending_bytes_limit</code> <code>int | None</code> <p>The pending bytes limit for this endpoint.</p> <code>None</code> <code>pending_msgs_limit</code> <code>int | None</code> <p>The pending messages limit for this endpoint.</p> <code>None</code> Source code in <code>src/nats_contrib/micro/api.py</code> <pre><code>async def add_endpoint(\n    self,\n    name: str,\n    handler: Handler,\n    subject: str | None = None,\n    queue_group: str | None = None,\n    metadata: dict[str, str] | None = None,\n    pending_bytes_limit: int | None = None,\n    pending_msgs_limit: int | None = None,\n) -&gt; Endpoint:\n    \"\"\"Add an endpoint to the service.\n\n    An endpoint is a request-reply handler for a subject.\n\n    Args:\n        name: The name of the endpoint.\n        handler: The handler of the endpoint.\n        subject: The subject of the endpoint. When subject is not set, it defaults to the name of the endpoint.\n        queue_group: The queue group of the endpoint. When queue group is not set, it defaults to the queue group of the parent group or service.\n        metadata: The metadata of the endpoint.\n        pending_bytes_limit: The pending bytes limit for this endpoint.\n        pending_msgs_limit: The pending messages limit for this endpoint.\n    \"\"\"\n    if self._stopped:\n        raise RuntimeError(\"Cannot add endpoint to a stopped service\")\n    config = self._config.endpoint_config(\n        name=name,\n        handler=handler,\n        subject=subject,\n        queue_group=queue_group,\n        metadata=metadata,\n        pending_bytes_limit=pending_bytes_limit,\n        pending_msgs_limit=pending_msgs_limit,\n    )\n    # Create the endpoint\n    ep = Endpoint(config)\n    # Create the endpoint handler\n    subscription_handler = _create_handler(ep)\n    # Start the endpoint subscription\n    subscription = (\n        await self._nc.subscribe(  # pyright: ignore[reportUnknownMemberType]\n            config.subject,\n            queue=config.queue_group,\n            cb=subscription_handler,\n        )\n    )\n    # Attach the subscription to the endpoint\n    ep._sub = subscription  # pyright: ignore[reportPrivateUsage]\n    # Append the endpoint to the service\n    self._endpoints.append(ep)\n    # Append the endpoint to the service stats and info\n    self._stats.endpoints.append(ep.stats)\n    self._info.endpoints.append(ep.info)\n    return ep\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.Service.add_group","title":"<code>add_group(name, queue_group=None, pending_bytes_limit_by_endpoint=None, pending_msgs_limit_by_endpoint=None)</code>","text":"<p>Add a group to the service.</p> <p>A group is a collection of endpoints that share the same prefix, and the same default queue group and pending limits.</p> <p>At runtime, a group does not exist as a separate entity, only endpoints exist. However, groups are useful to organize endpoints and to set default values for queue group and pending limits.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the group.</p> required <code>queue_group</code> <code>str | None</code> <p>The default queue group of the group. When queue group is not set, it defaults to the queue group of the parent group or service.</p> <code>None</code> <code>pending_bytes_limit_by_endpoint</code> <code>int | None</code> <p>The default pending bytes limit for each endpoint within the group.</p> <code>None</code> <code>pending_msgs_limit_by_endpoint</code> <code>int | None</code> <p>The default pending messages limit for each endpoint within the group.</p> <code>None</code> Source code in <code>src/nats_contrib/micro/api.py</code> <pre><code>def add_group(\n    self,\n    name: str,\n    queue_group: str | None = None,\n    pending_bytes_limit_by_endpoint: int | None = None,\n    pending_msgs_limit_by_endpoint: int | None = None,\n) -&gt; Group:\n    \"\"\"Add a group to the service.\n\n    A group is a collection of endpoints that share the same prefix,\n    and the same default queue group and pending limits.\n\n    At runtime, a group does not exist as a separate entity, only\n    endpoints exist. However, groups are useful to organize endpoints\n    and to set default values for queue group and pending limits.\n\n    Args:\n        name: The name of the group.\n        queue_group: The default queue group of the group. When queue group is not set, it defaults to the queue group of the parent group or service.\n        pending_bytes_limit_by_endpoint: The default pending bytes limit for each endpoint within the group.\n        pending_msgs_limit_by_endpoint: The default pending messages limit for each endpoint within the group.\n    \"\"\"\n    config = internal.GroupConfig(\n        name=name,\n        queue_group=queue_group or self._config.queue_group,\n        pending_bytes_limit_by_endpoint=pending_bytes_limit_by_endpoint\n        or self._config.pending_bytes_limit_by_endpoint,\n        pending_msgs_limit_by_endpoint=pending_msgs_limit_by_endpoint\n        or self._config.pending_msgs_limit_by_endpoint,\n    )\n    return Group(config, self)\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.Service.info","title":"<code>info()</code>","text":"<p>Returns the service info.</p> Source code in <code>src/nats_contrib/micro/api.py</code> <pre><code>def info(self) -&gt; ServiceInfo:\n    \"\"\"Returns the service info.\"\"\"\n    return self._info.copy()\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.Service.reset","title":"<code>reset()</code>","text":"<p>Resets all statistics (for all endpoints) on a service instance.</p> Source code in <code>src/nats_contrib/micro/api.py</code> <pre><code>def reset(self) -&gt; None:\n    \"\"\"Resets all statistics (for all endpoints) on a service instance.\"\"\"\n\n    # Internal responses\n    self._stats = internal.new_service_stats(self._id, self._clock(), self._config)\n    self._info = internal.new_service_info(self._id, self._config)\n    self._ping_response = internal.new_ping_info(self._id, self._config)\n    self._ping_response_message = internal.encode_ping_info(self._ping_response)\n    # Reset all endpoints\n    endpoints = list(self._endpoints)\n    self._endpoints.clear()\n    for ep in endpoints:\n        ep.reset()\n        self._endpoints.append(ep)\n        self._stats.endpoints.append(ep.stats)\n        self._info.endpoints.append(ep.info)\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.Service.start","title":"<code>start()</code>  <code>async</code>","text":"<p>Start the service.</p> <p>A service MUST be started before adding endpoints.</p> <p>This will start the internal subscriptions and enable service discovery.</p> Source code in <code>src/nats_contrib/micro/api.py</code> <pre><code>async def start(self) -&gt; None:\n    \"\"\"Start the service.\n\n    A service MUST be started before adding endpoints.\n\n    This will start the internal subscriptions and enable\n    service discovery.\n    \"\"\"\n    # Start PING subscriptions:\n    # - $SRV.PING\n    # - $SRV.{name}.PING\n    # - $SRV.{name}.{id}.PING\n    for subject in internal.get_internal_subjects(\n        internal.ServiceVerb.PING,\n        self._id,\n        self._config,\n        api_prefix=self._api_prefix,\n    ):\n        sub = await self._nc.subscribe(  # pyright: ignore[reportUnknownMemberType]\n            subject,\n            cb=self._handle_ping_request,\n        )\n        self._ping_subscriptions.append(sub)\n    # Start INFO subscriptions:\n    # - $SRV.INFO\n    # - $SRV.{name}.INFO\n    # - $SRV.{name}.{id}.INFO\n    for subject in internal.get_internal_subjects(\n        internal.ServiceVerb.INFO,\n        self._id,\n        self._config,\n        api_prefix=self._api_prefix,\n    ):\n        sub = await self._nc.subscribe(  # pyright: ignore[reportUnknownMemberType]\n            subject,\n            cb=self._handle_info_request,\n        )\n        self._info_subscriptions.append(sub)\n    # Start STATS subscriptions:\n    # - $SRV.STATS\n    # - $SRV.{name}.STATS\n    # - $SRV.{name}.{id}.STATS\n    for subject in internal.get_internal_subjects(\n        internal.ServiceVerb.STATS,\n        self._id,\n        self._config,\n        api_prefix=self._api_prefix,\n    ):\n        sub = await self._nc.subscribe(  # pyright: ignore[reportUnknownMemberType]\n            subject,\n            cb=self._handle_stats_request,\n        )\n        self._stats_subscriptions.append(sub)\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.Service.stats","title":"<code>stats()</code>","text":"<p>Returns statistics for the service endpoint and all monitoring endpoints.</p> Source code in <code>src/nats_contrib/micro/api.py</code> <pre><code>def stats(self) -&gt; ServiceStats:\n    \"\"\"Returns statistics for the service endpoint and all monitoring endpoints.\"\"\"\n    return self._stats.copy()\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.Service.stop","title":"<code>stop()</code>  <code>async</code>","text":"<p>Stop the service.</p> <p>This will stop all endpoints and internal subscriptions.</p> Source code in <code>src/nats_contrib/micro/api.py</code> <pre><code>async def stop(self) -&gt; None:\n    \"\"\"Stop the service.\n\n    This will stop all endpoints and internal subscriptions.\n    \"\"\"\n    self._stopped = True\n    # Stop all endpoints\n    await asyncio.gather(*(ep.stop() for ep in self._endpoints))\n    # Stop all internal subscriptions\n    await asyncio.gather(\n        *(\n            unsubscribe(sub)\n            for subscriptions in (\n                self._stats_subscriptions,\n                self._info_subscriptions,\n                self._ping_subscriptions,\n            )\n            for sub in subscriptions\n        )\n    )\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.Service.stopped","title":"<code>stopped()</code>","text":"<p>Stopped informs whether [Stop] was executed on the service.</p> Source code in <code>src/nats_contrib/micro/api.py</code> <pre><code>def stopped(self) -&gt; bool:\n    \"\"\"Stopped informs whether [Stop] was executed on the service.\"\"\"\n    return self._stopped\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.ServiceError","title":"<code>ServiceError</code>","text":"<p>             Bases: <code>Exception</code></p> <p>Raised when a service error is received.</p> Source code in <code>src/nats_contrib/micro/client.py</code> <pre><code>class ServiceError(Exception):\n    \"\"\"Raised when a service error is received.\"\"\"\n\n    def __init__(self, code: int, description: str) -&gt; None:\n        super().__init__(f\"Service error {code}: {description}\")\n        self.code = code\n        self.description = description\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.ServiceInfo","title":"<code>ServiceInfo</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Base</code></p> <p>The information of a service.</p> Source code in <code>src/nats_contrib/micro/models.py</code> <pre><code>@dataclass\nclass ServiceInfo(Base):\n    \"\"\"The information of a service.\"\"\"\n\n    name: str\n    \"\"\"\n    The kind of the service. Shared by all the services that have the same name\n    \"\"\"\n    id: str\n    \"\"\"\n    A unique ID for this instance of a service\n    \"\"\"\n    version: str\n    \"\"\"\n    The version of the service\n    \"\"\"\n    description: str\n    \"\"\"\n    The description of the service supplied as configuration while creating the service\n    \"\"\"\n    metadata: dict[str, str]\n    \"\"\"\n    The service metadata\n    \"\"\"\n    endpoints: list[EndpointInfo]\n    \"\"\"\n    Information for all service endpoints\n    \"\"\"\n    type: str = \"io.nats.micro.v1.info_response\"\n\n    def copy(self) -&gt; ServiceInfo:\n        return replace(\n            self,\n            endpoints=[ep.copy() for ep in self.endpoints],\n            metadata=self.metadata.copy(),\n        )\n\n    def as_dict(self) -&gt; dict[str, Any]:\n        \"\"\"Return the object converted into an API-friendly dict.\"\"\"\n        result = super().as_dict()\n        result[\"endpoints\"] = [ep.as_dict() for ep in self.endpoints]\n        return result\n\n    @classmethod\n    def from_response(cls, resp: dict[str, Any]) -&gt; ServiceInfo:\n        \"\"\"Read the class instance from a server response.\n\n        Unknown fields are ignored (\"open-world assumption\").\n        \"\"\"\n        info = super().from_response(resp)\n        info.endpoints = [EndpointInfo(**ep) for ep in resp[\"endpoints\"]]\n        return info\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.ServiceInfo.description","title":"<code>description: str</code>  <code>instance-attribute</code>","text":"<p>The description of the service supplied as configuration while creating the service</p>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.ServiceInfo.endpoints","title":"<code>endpoints: list[EndpointInfo]</code>  <code>instance-attribute</code>","text":"<p>Information for all service endpoints</p>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.ServiceInfo.id","title":"<code>id: str</code>  <code>instance-attribute</code>","text":"<p>A unique ID for this instance of a service</p>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.ServiceInfo.metadata","title":"<code>metadata: dict[str, str]</code>  <code>instance-attribute</code>","text":"<p>The service metadata</p>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.ServiceInfo.name","title":"<code>name: str</code>  <code>instance-attribute</code>","text":"<p>The kind of the service. Shared by all the services that have the same name</p>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.ServiceInfo.version","title":"<code>version: str</code>  <code>instance-attribute</code>","text":"<p>The version of the service</p>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.ServiceInfo.as_dict","title":"<code>as_dict()</code>","text":"<p>Return the object converted into an API-friendly dict.</p> Source code in <code>src/nats_contrib/micro/models.py</code> <pre><code>def as_dict(self) -&gt; dict[str, Any]:\n    \"\"\"Return the object converted into an API-friendly dict.\"\"\"\n    result = super().as_dict()\n    result[\"endpoints\"] = [ep.as_dict() for ep in self.endpoints]\n    return result\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.ServiceInfo.from_response","title":"<code>from_response(resp)</code>  <code>classmethod</code>","text":"<p>Read the class instance from a server response.</p> <p>Unknown fields are ignored (\"open-world assumption\").</p> Source code in <code>src/nats_contrib/micro/models.py</code> <pre><code>@classmethod\ndef from_response(cls, resp: dict[str, Any]) -&gt; ServiceInfo:\n    \"\"\"Read the class instance from a server response.\n\n    Unknown fields are ignored (\"open-world assumption\").\n    \"\"\"\n    info = super().from_response(resp)\n    info.endpoints = [EndpointInfo(**ep) for ep in resp[\"endpoints\"]]\n    return info\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.ServiceStats","title":"<code>ServiceStats</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Base</code></p> <p>The statistics of a service.</p> Source code in <code>src/nats_contrib/micro/models.py</code> <pre><code>@dataclass\nclass ServiceStats(Base):\n    \"\"\"The statistics of a service.\"\"\"\n\n    name: str\n    \"\"\"\n    The kind of the service. Shared by all the services that have the same name\n    \"\"\"\n    id: str\n    \"\"\"\n    A unique ID for this instance of a service\n    \"\"\"\n    version: str\n    \"\"\"\n    The version of the service\n    \"\"\"\n    started: str\n    \"\"\"\n    The time the service was stated in RFC3339 format\n    \"\"\"\n    endpoints: list[EndpointStats]\n    \"\"\"\n    Statistics for each known endpoint\n    \"\"\"\n    metadata: dict[str, str] | None = None\n    \"\"\"Service metadata.\"\"\"\n\n    type: str = \"io.nats.micro.v1.stats_response\"\n\n    def copy(self) -&gt; ServiceStats:\n        return replace(\n            self,\n            endpoints=[ep.copy() for ep in self.endpoints],\n            metadata=None if self.metadata is None else self.metadata.copy(),\n        )\n\n    def as_dict(self) -&gt; dict[str, Any]:\n        \"\"\"Return the object converted into an API-friendly dict.\"\"\"\n        result = super().as_dict()\n        result[\"endpoints\"] = [ep.as_dict() for ep in self.endpoints]\n        return result\n\n    @classmethod\n    def from_response(cls, resp: dict[str, Any]) -&gt; ServiceStats:\n        \"\"\"Read the class instance from a server response.\n\n        Unknown fields are ignored (\"open-world assumption\").\n        \"\"\"\n        stats = super().from_response(resp)\n        stats.endpoints = [EndpointStats.from_response(ep) for ep in resp[\"endpoints\"]]\n        return stats\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.ServiceStats.endpoints","title":"<code>endpoints: list[EndpointStats]</code>  <code>instance-attribute</code>","text":"<p>Statistics for each known endpoint</p>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.ServiceStats.id","title":"<code>id: str</code>  <code>instance-attribute</code>","text":"<p>A unique ID for this instance of a service</p>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.ServiceStats.metadata","title":"<code>metadata: dict[str, str] | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Service metadata.</p>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.ServiceStats.name","title":"<code>name: str</code>  <code>instance-attribute</code>","text":"<p>The kind of the service. Shared by all the services that have the same name</p>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.ServiceStats.started","title":"<code>started: str</code>  <code>instance-attribute</code>","text":"<p>The time the service was stated in RFC3339 format</p>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.ServiceStats.version","title":"<code>version: str</code>  <code>instance-attribute</code>","text":"<p>The version of the service</p>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.ServiceStats.as_dict","title":"<code>as_dict()</code>","text":"<p>Return the object converted into an API-friendly dict.</p> Source code in <code>src/nats_contrib/micro/models.py</code> <pre><code>def as_dict(self) -&gt; dict[str, Any]:\n    \"\"\"Return the object converted into an API-friendly dict.\"\"\"\n    result = super().as_dict()\n    result[\"endpoints\"] = [ep.as_dict() for ep in self.endpoints]\n    return result\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.ServiceStats.from_response","title":"<code>from_response(resp)</code>  <code>classmethod</code>","text":"<p>Read the class instance from a server response.</p> <p>Unknown fields are ignored (\"open-world assumption\").</p> Source code in <code>src/nats_contrib/micro/models.py</code> <pre><code>@classmethod\ndef from_response(cls, resp: dict[str, Any]) -&gt; ServiceStats:\n    \"\"\"Read the class instance from a server response.\n\n    Unknown fields are ignored (\"open-world assumption\").\n    \"\"\"\n    stats = super().from_response(resp)\n    stats.endpoints = [EndpointStats.from_response(ep) for ep in resp[\"endpoints\"]]\n    return stats\n</code></pre>"},{"location":"reference/nats_contrib/micro/#nats_contrib.micro.add_service","title":"<code>add_service(nc, name, version, description=None, metadata=None, queue_group=None, now=None, generate_id=None, api_prefix=None)</code>","text":"<p>Create a new service.</p> <p>A service is a collection of endpoints that are grouped together under a common name.</p> <p>Each endpoint is a request-reply handler for a subject.</p> <p>It's possible to add endpoints to a service after it has been created AND started.</p> <p>Parameters:</p> Name Type Description Default <code>nc</code> <code>Client</code> <p>The NATS client.</p> required <code>name</code> <code>str</code> <p>The name of the service.</p> required <code>version</code> <code>str</code> <p>The version of the service. Must be a valid semver version.</p> required <code>description</code> <code>str | None</code> <p>The description of the service.</p> <code>None</code> <code>metadata</code> <code>dict[str, str] | None</code> <p>The metadata of the service.</p> <code>None</code> <code>queue_group</code> <code>str | None</code> <p>The default queue group of the service.</p> <code>None</code> <code>now</code> <code>Callable[[], datetime] | None</code> <p>The function to get the current time.</p> <code>None</code> <code>generate_id</code> <code>Callable[[], str] | None</code> <p>The function to generate a unique service instance id.</p> <code>None</code> <code>api_prefix</code> <code>str | None</code> <p>The prefix of the control subjects.</p> <code>None</code> Source code in <code>src/nats_contrib/micro/api.py</code> <pre><code>def add_service(\n    nc: NatsClient,\n    name: str,\n    version: str,\n    description: str | None = None,\n    metadata: dict[str, str] | None = None,\n    queue_group: str | None = None,\n    now: Callable[[], datetime] | None = None,\n    generate_id: Callable[[], str] | None = None,\n    api_prefix: str | None = None,\n) -&gt; Service:\n    \"\"\"Create a new service.\n\n    A service is a collection of endpoints that are grouped together\n    under a common name.\n\n    Each endpoint is a request-reply handler for a subject.\n\n    It's possible to add endpoints to a service after it has been created AND\n    started.\n\n    Args:\n        nc: The NATS client.\n        name: The name of the service.\n        version: The version of the service. Must be a valid semver version.\n        description: The description of the service.\n        metadata: The metadata of the service.\n        queue_group: The default queue group of the service.\n        now: The function to get the current time.\n        generate_id: The function to generate a unique service instance id.\n        api_prefix: The prefix of the control subjects.\n    \"\"\"\n    if generate_id is None:\n        generate_id = token_hex\n    instance_id = generate_id()\n    service_config = internal.ServiceConfig(\n        name=name,\n        version=version,\n        description=description or \"\",\n        metadata=metadata or {},\n        queue_group=queue_group or DEFAULT_QUEUE_GROUP,\n        pending_bytes_limit_by_endpoint=DEFAULT_SUB_PENDING_BYTES_LIMIT,\n        pending_msgs_limit_by_endpoint=DEFAULT_SUB_PENDING_MSGS_LIMIT,\n    )\n    return Service(\n        nc=nc,\n        id=instance_id,\n        config=service_config,\n        api_prefix=api_prefix or API_PREFIX,\n        clock=now or internal.default_clock,\n    )\n</code></pre>"}]}