{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"NATS Micro for Python","text":"<p>This is not an official NATS project</p> <p>This is a personal project and is not endorsed by the NATS.io community. It is not guaranteed to be maintained or supported.</p> <p>This is an experimental project</p> <p>This project is a prototype and should not be used for anything serious. It is not tested, nor is it guaranteed to be correct.</p> <p>The <code>micro</code> package provides a simple way to create a microservice using the NATS messaging system.</p> <p>It is documented in ADR-32: Service API.</p> <p>The reference implementation is in nats.go under micro package.</p> <p>A typescript implementation is available in nats.deno</p>"},{"location":"#why-does-this-exist","title":"Why does this exist ?","text":"<ul> <li> <p>I wanted to give a try to implementing the ADR-32 in Python.</p> </li> <li> <p>Maybe this can help getting an official implementation in the NATS Python client.</p> </li> </ul>"},{"location":"#whats-lacking","title":"What's lacking ?","text":"<ul> <li>There is no test, and it may not be correct.</li> </ul>"},{"location":"#how-to-install","title":"How to install","text":"<pre><code>pip install git+https://github.com/charbonnierg/nats-micro.git\n</code></pre>"},{"location":"#api-proposal","title":"API Proposal","text":"<p>The API is inspired by the Go micro package:</p> <ul> <li>In order to use the package, you need to create a NATS connection using the nats.aio package:</li> </ul> <pre><code>from nats.aio.client import Client\n\n# Somewhere in an async function\nnc = await Client().connect(\"nats://localhost:4222\")\n</code></pre> <ul> <li>Create a new service with <code>micro.add_service</code>:</li> </ul> <pre><code>service = micro.add_service(\n    nc,\n    name=\"demo-service\",\n    version=\"1.0.0\",\n    description=\"Demo service\",\n)\n</code></pre> <ul> <li>Unlike the Go implementation, the service is not started automatically. You need to call <code>service.start</code> to start the service, or use the service as an async context manager which allows to both create and start the service in a single line:</li> </ul> <pre><code>async with micro.add_service(\n    nc,\n    name=\"demo-service\",\n    version=\"1.0.0\",\n    description=\"Demo service\",\n) as service:\n    ...\n</code></pre> <ul> <li>Once service is started, you can add endpoints to the service using <code>Service.add_endpoint</code>:</li> </ul> <pre><code>async def echo(req: micro.Request) -&gt; None:\n    \"\"\"Echo the request data back to the client.\"\"\"\n    await req.respond(req.data())\n\n\nawait service.add_endpoint(\n    name=\"echo\",\n    handler=echo,\n)\n</code></pre> <p>As defined in the ADR, an endpoint must provide at least a name and a handler. The handler is a coroutine that takes a <code>micro.Request</code> as its only argument and returns <code>None</code>.</p> <p>If no subject is provided, the endpoint will use the service name as the subject. It's possible to provide a subject with the <code>subject</code> argument:</p> <pre><code>await service.add_endpoint(\n    name=\"echo\",\n    handler=echo,\n    subject=\"ECHO\",\n)\n</code></pre> <ul> <li>You can also add groups to the service:</li> </ul> <pre><code>group = service.add_group(\"demo\")\n</code></pre> <p>As defined in the ADR, a group serves as a common prefix to all endpoints registered in it.</p> <ul> <li>You can add endpoints to a group using <code>Group.add_endpoint</code></li> </ul> <pre><code>await group.add_endpoint(\n    name=\"echo\",\n    handler=echo,\n)\n</code></pre> <p>This is equivalent to adding an endpoint to the service with the subject prefixed by the group name.</p> <ul> <li>Once you're done, you can stop the service with <code>service.stop()</code> if it was not used as an async context manager:</li> </ul> <pre><code>await service.stop()\n</code></pre> <ul> <li>You can check if the stop() method was called with <code>service.stopped</code>:</li> </ul> <pre><code>assert service.stopped\n</code></pre>"},{"location":"#example-usage","title":"Example usage","text":"<p>This example shows how to create a simple service that echoes the request data back to the client and to run it until the application receives a SIGINT or a SIGTERM signal.</p> <pre><code>import asyncio\nimport contextlib\nimport signal\n\nfrom nats.aio.client import Client\n\nimport micro\n\n\nasync def echo(req: micro.Request) -&gt; None:\n    \"\"\"Echo the request data back to the client.\"\"\"\n    await req.respond(req.data())\n\n\nasync def main():\n    # Define an event to signal when to quit\n    quit_event = asyncio.Event()\n    # Attach signal handler to the event loop\n    loop = asyncio.get_event_loop()\n    for sig in (signal.Signals.SIGINT, signal.Signals.SIGTERM):\n        loop.add_signal_handler(sig, lambda *_: quit_event.set())\n    # Create an async exit stack\n    async with contextlib.AsyncExitStack() as stack:\n        # Create a NATS client\n        nc = Client()\n        # Connect to NATS\n        await nc.connect(\"nats://localhost:4222\")\n        # Push the client.close() method into the stack to be called on exit\n        stack.push_async_callback(nc.close)\n        # Push a new micro service into the stack to be stopped on exit\n        # The service will be stopped and drain its subscriptions before\n        # closing the connection.\n        service = await stack.enter_async_context(\n            micro.add_service(\n                nc,\n                name=\"demo-service\",\n                version=\"1.0.0\",\n                description=\"Demo service\",\n            )\n        )\n        group = service.add_group(\"demo\")\n        # Add an endpoint to the service\n        await group.add_endpoint(\n            name=\"echo\",\n            handler=echo,\n        )\n        # Wait for the quit event\n        await quit_event.wait()\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"LICENSE/","title":"License","text":"<p>MIT License</p> <p>Copyright (c) 2024 Guillaume Charbonnier</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"SUMMARY/","title":"SUMMARY","text":"<ul> <li>Home</li> <li>Reference</li> <li>License</li> </ul>"},{"location":"reference/micro/","title":"Reference","text":""},{"location":"reference/micro/#micro.Endpoint","title":"<code>Endpoint</code>","text":"<p>Endpoint manages a service endpoint.</p> Source code in <code>src/micro/api.py</code> <pre><code>class Endpoint:\n    \"\"\"Endpoint manages a service endpoint.\"\"\"\n\n    def __init__(self, config: internal.EndpointConfig) -&gt; None:\n        self.config = config\n        self.stats = internal.create_endpoint_stats(config)\n        self.info = internal.create_endpoint_info(config)\n        self._sub: Subscription | None = None\n\n    async def stop(self) -&gt; None:\n        \"\"\"Stop the endpoint by draining its subscription.\"\"\"\n        if self._sub:\n            await self._sub.drain()\n            self._sub = None\n</code></pre>"},{"location":"reference/micro/#micro.Endpoint.stop","title":"<code>stop()</code>  <code>async</code>","text":"<p>Stop the endpoint by draining its subscription.</p> Source code in <code>src/micro/api.py</code> <pre><code>async def stop(self) -&gt; None:\n    \"\"\"Stop the endpoint by draining its subscription.\"\"\"\n    if self._sub:\n        await self._sub.drain()\n        self._sub = None\n</code></pre>"},{"location":"reference/micro/#micro.EndpointInfo","title":"<code>EndpointInfo</code>  <code>dataclass</code>","text":"<p>The information of an endpoint.</p> Source code in <code>src/micro/models.py</code> <pre><code>@dataclass\nclass EndpointInfo:\n    \"\"\"The information of an endpoint.\"\"\"\n\n    name: str\n    subject: str\n    metadata: dict[str, str]\n    queue_group: str\n\n    def copy(self) -&gt; EndpointInfo:\n        return replace(self, metadata=self.metadata.copy())\n</code></pre>"},{"location":"reference/micro/#micro.EndpointStats","title":"<code>EndpointStats</code>  <code>dataclass</code>","text":"<p>The statistics of an endpoint.</p> Source code in <code>src/micro/models.py</code> <pre><code>@dataclass\nclass EndpointStats:\n    \"\"\"The statistics of an endpoint.\"\"\"\n\n    name: str\n    subject: str\n    num_requests: int\n    num_errors: int\n    last_error: str\n    processing_time: int\n    average_processing_time: int\n    queue_group: str\n    data: dict[str, object]\n\n    def copy(self) -&gt; EndpointStats:\n        return replace(self, data=self.data.copy())\n</code></pre>"},{"location":"reference/micro/#micro.Group","title":"<code>Group</code>","text":"<p>Group allows for grouping endpoints on a service.</p> <p>Endpoints created using <code>Group.add_endpoint</code> will be grouped under common prefix (group name). New groups can also be derived from a group using <code>Group.add_group</code>.</p> Source code in <code>src/micro/api.py</code> <pre><code>class Group:\n    \"\"\"Group allows for grouping endpoints on a service.\n\n    Endpoints created using `Group.add_endpoint` will be grouped\n    under common prefix (group name). New groups can also be derived\n    from a group using `Group.add_group`.\n    \"\"\"\n\n    def __init__(self, config: internal.GroupConfig, service: Service) -&gt; None:\n        self._config = config\n        self._service = service\n\n    def add_group(\n        self,\n        name: str,\n        queue_group: str | None = None,\n        pending_bytes_limit: int | None = None,\n        pending_msgs_limit: int | None = None,\n    ) -&gt; Group:\n        \"\"\"Add a group to the group.\n\n        Args:\n            name: The name of the group. Must be a valid NATS subject prefix.\n            queue_group: The default queue group of the group. When queue group is not set, it defaults to the queue group of the parent group or service.\n            pending_bytes_limit: The default pending bytes limit for each endpoint within the group.\n            pending_msgs_limit: The default pending messages limit for each endpoint within the group.\n        \"\"\"\n        config = self._config.child(\n            name=name,\n            queue_group=queue_group,\n            pending_bytes_limit=pending_bytes_limit,\n            pending_msgs_limit=pending_msgs_limit,\n        )\n        group = Group(config, self._service)\n        return group\n\n    async def add_endpoint(\n        self,\n        name: str,\n        handler: Handler,\n        subject: str | None = None,\n        queue_group: str | None = None,\n        metadata: dict[str, str] | None = None,\n        pending_bytes_limit: int | None = None,\n        pending_msgs_limit: int | None = None,\n    ) -&gt; Endpoint:\n        \"\"\"Add an endpoint to the group.\n\n        Args:\n            name: The name of the endpoint.\n            handler: The handler of the endpoint.\n            subject: The subject of the endpoint. When subject is not set, it defaults to the name of the endpoint.\n            queue_group: The queue group of the endpoint. When queue group is not set, it defaults to the queue group of the parent group or service.\n            metadata: The metadata of the endpoint.\n            pending_bytes_limit: The pending bytes limit for this endpoint.\n            pending_msgs_limit: The pending messages limit for this endpoint.\n        \"\"\"\n        return await self._service.add_endpoint(\n            name=name,\n            subject=f\"{self._config.name}.{subject or name}\",\n            handler=handler,\n            metadata=metadata,\n            queue_group=queue_group or self._config.queue_group,\n            pending_bytes_limit=pending_bytes_limit\n            or self._config.pending_bytes_limit_by_endpoint,\n            pending_msgs_limit=pending_msgs_limit\n            or self._config.pending_msgs_limit_by_endpoint,\n        )\n</code></pre>"},{"location":"reference/micro/#micro.Group.add_endpoint","title":"<code>add_endpoint(name, handler, subject=None, queue_group=None, metadata=None, pending_bytes_limit=None, pending_msgs_limit=None)</code>  <code>async</code>","text":"<p>Add an endpoint to the group.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the endpoint.</p> required <code>handler</code> <code>Handler</code> <p>The handler of the endpoint.</p> required <code>subject</code> <code>str | None</code> <p>The subject of the endpoint. When subject is not set, it defaults to the name of the endpoint.</p> <code>None</code> <code>queue_group</code> <code>str | None</code> <p>The queue group of the endpoint. When queue group is not set, it defaults to the queue group of the parent group or service.</p> <code>None</code> <code>metadata</code> <code>dict[str, str] | None</code> <p>The metadata of the endpoint.</p> <code>None</code> <code>pending_bytes_limit</code> <code>int | None</code> <p>The pending bytes limit for this endpoint.</p> <code>None</code> <code>pending_msgs_limit</code> <code>int | None</code> <p>The pending messages limit for this endpoint.</p> <code>None</code> Source code in <code>src/micro/api.py</code> <pre><code>async def add_endpoint(\n    self,\n    name: str,\n    handler: Handler,\n    subject: str | None = None,\n    queue_group: str | None = None,\n    metadata: dict[str, str] | None = None,\n    pending_bytes_limit: int | None = None,\n    pending_msgs_limit: int | None = None,\n) -&gt; Endpoint:\n    \"\"\"Add an endpoint to the group.\n\n    Args:\n        name: The name of the endpoint.\n        handler: The handler of the endpoint.\n        subject: The subject of the endpoint. When subject is not set, it defaults to the name of the endpoint.\n        queue_group: The queue group of the endpoint. When queue group is not set, it defaults to the queue group of the parent group or service.\n        metadata: The metadata of the endpoint.\n        pending_bytes_limit: The pending bytes limit for this endpoint.\n        pending_msgs_limit: The pending messages limit for this endpoint.\n    \"\"\"\n    return await self._service.add_endpoint(\n        name=name,\n        subject=f\"{self._config.name}.{subject or name}\",\n        handler=handler,\n        metadata=metadata,\n        queue_group=queue_group or self._config.queue_group,\n        pending_bytes_limit=pending_bytes_limit\n        or self._config.pending_bytes_limit_by_endpoint,\n        pending_msgs_limit=pending_msgs_limit\n        or self._config.pending_msgs_limit_by_endpoint,\n    )\n</code></pre>"},{"location":"reference/micro/#micro.Group.add_group","title":"<code>add_group(name, queue_group=None, pending_bytes_limit=None, pending_msgs_limit=None)</code>","text":"<p>Add a group to the group.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the group. Must be a valid NATS subject prefix.</p> required <code>queue_group</code> <code>str | None</code> <p>The default queue group of the group. When queue group is not set, it defaults to the queue group of the parent group or service.</p> <code>None</code> <code>pending_bytes_limit</code> <code>int | None</code> <p>The default pending bytes limit for each endpoint within the group.</p> <code>None</code> <code>pending_msgs_limit</code> <code>int | None</code> <p>The default pending messages limit for each endpoint within the group.</p> <code>None</code> Source code in <code>src/micro/api.py</code> <pre><code>def add_group(\n    self,\n    name: str,\n    queue_group: str | None = None,\n    pending_bytes_limit: int | None = None,\n    pending_msgs_limit: int | None = None,\n) -&gt; Group:\n    \"\"\"Add a group to the group.\n\n    Args:\n        name: The name of the group. Must be a valid NATS subject prefix.\n        queue_group: The default queue group of the group. When queue group is not set, it defaults to the queue group of the parent group or service.\n        pending_bytes_limit: The default pending bytes limit for each endpoint within the group.\n        pending_msgs_limit: The default pending messages limit for each endpoint within the group.\n    \"\"\"\n    config = self._config.child(\n        name=name,\n        queue_group=queue_group,\n        pending_bytes_limit=pending_bytes_limit,\n        pending_msgs_limit=pending_msgs_limit,\n    )\n    group = Group(config, self._service)\n    return group\n</code></pre>"},{"location":"reference/micro/#micro.Request","title":"<code>Request</code>","text":"<p>Request is the interface for a request received by a service.</p> <p>An interface is used instead of a class to allow for different implementations. It makes it easy to test a service by using a stub implementation of Request.</p> <p>Four methods must be implemented:</p> <ul> <li><code>def subject() -&gt; str</code>: the subject on which the request was received.</li> <li><code>def headers() -&gt; dict[str, str]</code>: the headers of the request.</li> <li><code>def data() -&gt; bytes</code>: the data of the request.</li> <li><code>async def respond(...) -&gt; None</code>: send a response to the request.</li> </ul> Source code in <code>src/micro/request.py</code> <pre><code>class Request(metaclass=abc.ABCMeta):\n    \"\"\"Request is the interface for a request received by a service.\n\n    An interface is used instead of a class to allow for different implementations.\n    It makes it easy to test a service by using a stub implementation of Request.\n\n    Four methods must be implemented:\n\n    - `def subject() -&gt; str`: the subject on which the request was received.\n    - `def headers() -&gt; dict[str, str]`: the headers of the request.\n    - `def data() -&gt; bytes`: the data of the request.\n    - `async def respond(...) -&gt; None`: send a response to the request.\n    \"\"\"\n\n    @abc.abstractmethod\n    def subject(self) -&gt; str:\n        \"\"\"The subject on which request was received.\"\"\"\n        raise NotImplementedError()\n\n    @abc.abstractmethod\n    def headers(self) -&gt; dict[str, str]:\n        \"\"\"The headers of the request.\"\"\"\n        raise NotImplementedError()\n\n    @abc.abstractmethod\n    def data(self) -&gt; bytes:\n        \"\"\"The data of the request.\"\"\"\n        raise NotImplementedError()\n\n    @abc.abstractmethod\n    async def respond(self, data: bytes, headers: dict[str, str] | None = None) -&gt; None:\n        \"\"\"Send a success response to the request.\n\n        Args:\n            data: The response data.\n            headers: Additional response headers.\n        \"\"\"\n        raise NotImplementedError()\n\n    async def respond_success(\n        self,\n        code: int,\n        data: bytes | None = None,\n        headers: dict[str, str] | None = None,\n    ) -&gt; None:\n        \"\"\"Send a success response to the request.\n\n        Args:\n            code: The status code describing the success.\n            data: The response data.\n            headers: Additional response headers.\n        \"\"\"\n        if not headers:\n            headers = {}\n        headers[\"Nats-Service-Success-Code\"] = str(code)\n        await self.respond(data or b\"\", headers=headers)\n\n    async def respond_error(\n        self,\n        code: int,\n        description: str,\n        data: bytes | None = None,\n        headers: dict[str, str] | None = None,\n    ) -&gt; None:\n        \"\"\"Send an error response to the request.\n\n        Args:\n            code: The error code describing the error.\n            description: A string describing the error which can be displayed to the client.\n            data: The error data.\n            headers: Additional response headers.\n        \"\"\"\n        if not headers:\n            headers = {}\n        headers[\"Nats-Service-Error\"] = description\n        headers[\"Nats-Service-Error-Code\"] = str(code)\n        await self.respond(data or b\"\", headers=headers)\n</code></pre>"},{"location":"reference/micro/#micro.Request.data","title":"<code>data()</code>  <code>abstractmethod</code>","text":"<p>The data of the request.</p> Source code in <code>src/micro/request.py</code> <pre><code>@abc.abstractmethod\ndef data(self) -&gt; bytes:\n    \"\"\"The data of the request.\"\"\"\n    raise NotImplementedError()\n</code></pre>"},{"location":"reference/micro/#micro.Request.headers","title":"<code>headers()</code>  <code>abstractmethod</code>","text":"<p>The headers of the request.</p> Source code in <code>src/micro/request.py</code> <pre><code>@abc.abstractmethod\ndef headers(self) -&gt; dict[str, str]:\n    \"\"\"The headers of the request.\"\"\"\n    raise NotImplementedError()\n</code></pre>"},{"location":"reference/micro/#micro.Request.respond","title":"<code>respond(data, headers=None)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Send a success response to the request.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>bytes</code> <p>The response data.</p> required <code>headers</code> <code>dict[str, str] | None</code> <p>Additional response headers.</p> <code>None</code> Source code in <code>src/micro/request.py</code> <pre><code>@abc.abstractmethod\nasync def respond(self, data: bytes, headers: dict[str, str] | None = None) -&gt; None:\n    \"\"\"Send a success response to the request.\n\n    Args:\n        data: The response data.\n        headers: Additional response headers.\n    \"\"\"\n    raise NotImplementedError()\n</code></pre>"},{"location":"reference/micro/#micro.Request.respond_error","title":"<code>respond_error(code, description, data=None, headers=None)</code>  <code>async</code>","text":"<p>Send an error response to the request.</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>int</code> <p>The error code describing the error.</p> required <code>description</code> <code>str</code> <p>A string describing the error which can be displayed to the client.</p> required <code>data</code> <code>bytes | None</code> <p>The error data.</p> <code>None</code> <code>headers</code> <code>dict[str, str] | None</code> <p>Additional response headers.</p> <code>None</code> Source code in <code>src/micro/request.py</code> <pre><code>async def respond_error(\n    self,\n    code: int,\n    description: str,\n    data: bytes | None = None,\n    headers: dict[str, str] | None = None,\n) -&gt; None:\n    \"\"\"Send an error response to the request.\n\n    Args:\n        code: The error code describing the error.\n        description: A string describing the error which can be displayed to the client.\n        data: The error data.\n        headers: Additional response headers.\n    \"\"\"\n    if not headers:\n        headers = {}\n    headers[\"Nats-Service-Error\"] = description\n    headers[\"Nats-Service-Error-Code\"] = str(code)\n    await self.respond(data or b\"\", headers=headers)\n</code></pre>"},{"location":"reference/micro/#micro.Request.respond_success","title":"<code>respond_success(code, data=None, headers=None)</code>  <code>async</code>","text":"<p>Send a success response to the request.</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>int</code> <p>The status code describing the success.</p> required <code>data</code> <code>bytes | None</code> <p>The response data.</p> <code>None</code> <code>headers</code> <code>dict[str, str] | None</code> <p>Additional response headers.</p> <code>None</code> Source code in <code>src/micro/request.py</code> <pre><code>async def respond_success(\n    self,\n    code: int,\n    data: bytes | None = None,\n    headers: dict[str, str] | None = None,\n) -&gt; None:\n    \"\"\"Send a success response to the request.\n\n    Args:\n        code: The status code describing the success.\n        data: The response data.\n        headers: Additional response headers.\n    \"\"\"\n    if not headers:\n        headers = {}\n    headers[\"Nats-Service-Success-Code\"] = str(code)\n    await self.respond(data or b\"\", headers=headers)\n</code></pre>"},{"location":"reference/micro/#micro.Request.subject","title":"<code>subject()</code>  <code>abstractmethod</code>","text":"<p>The subject on which request was received.</p> Source code in <code>src/micro/request.py</code> <pre><code>@abc.abstractmethod\ndef subject(self) -&gt; str:\n    \"\"\"The subject on which request was received.\"\"\"\n    raise NotImplementedError()\n</code></pre>"},{"location":"reference/micro/#micro.Service","title":"<code>Service</code>","text":"Source code in <code>src/micro/api.py</code> <pre><code>class Service:\n    def __init__(\n        self,\n        nc: NatsClient,\n        config: internal.ServiceConfig,\n        api_prefix: str,\n    ) -&gt; None:\n        self._nc = nc\n        self._config = config\n        self._api_prefix = api_prefix\n        # Initialize state\n        self._id = token_hex(12)\n        self._endpoints: list[Endpoint] = []\n        self._stopped = False\n        # Internal responses\n        self._stats = internal.create_service_stats(\n            self._id, datetime.now(timezone.utc), config\n        )\n        self._info = internal.create_service_info(self._id, config)\n        self._ping_response = internal.create_ping_info(self._id, config)\n        # Cache the serialized ping response\n        self._ping_response_message = dumps(asdict(self._ping_response)).encode()\n        # Internal subscriptions\n        self._ping_subscriptions: list[Subscription] = []\n        self._info_subscriptions: list[Subscription] = []\n        self._stats_subscriptions: list[Subscription] = []\n\n    async def start(self) -&gt; None:\n        \"\"\"Start the service.\n\n        A service MUST be started before adding endpoints.\n\n        This will start the internal subscriptions and enable\n        service discovery.\n        \"\"\"\n        for subject in internal.get_internal_subjects(\n            internal.ServiceVerb.PING,\n            self._id,\n            self._config,\n            api_prefix=self._api_prefix,\n        ):\n            sub = await self._nc.subscribe(  # pyright: ignore[reportUnknownMemberType]\n                subject,\n                cb=self._handle_ping_request,\n            )\n            self._ping_subscriptions.append(sub)\n\n        for subject in internal.get_internal_subjects(\n            internal.ServiceVerb.INFO,\n            self._id,\n            self._config,\n            api_prefix=self._api_prefix,\n        ):\n            sub = await self._nc.subscribe(  # pyright: ignore[reportUnknownMemberType]\n                subject,\n                cb=self._handle_info_request,\n            )\n            self._info_subscriptions.append(sub)\n\n        for subject in internal.get_internal_subjects(\n            internal.ServiceVerb.STATS,\n            self._id,\n            self._config,\n            api_prefix=self._api_prefix,\n        ):\n            sub = await self._nc.subscribe(  # pyright: ignore[reportUnknownMemberType]\n                subject,\n                cb=self._handle_stats_request,\n            )\n            self._stats_subscriptions.append(sub)\n\n    async def stop(self) -&gt; None:\n        \"\"\"Stop the service.\n\n        This will stop all endpoints and internal subscriptions.\n        \"\"\"\n        self._stopped = True\n        # Stop endpoints\n        await asyncio.gather(*(ep.stop() for ep in self._endpoints))\n        # Stop internal subscriptions\n        await asyncio.gather(\n            *(\n                sub.unsubscribe()\n                for subscriptions in (\n                    self._stats_subscriptions,\n                    self._info_subscriptions,\n                    self._ping_subscriptions,\n                )\n                for sub in subscriptions\n            )\n        )\n\n    def stopped(self) -&gt; bool:\n        \"\"\"Stopped informs whether [Stop] was executed on the service.\"\"\"\n        return self._stopped\n\n    def info(self) -&gt; ServiceInfo:\n        \"\"\"Returns the service info.\"\"\"\n        return self._info.copy()\n\n    def stats(self) -&gt; ServiceStats:\n        \"\"\"Returns statistics for the service endpoint and all monitoring endpoints.\"\"\"\n        return self._stats.copy()\n\n    def reset(self) -&gt; None:\n        \"\"\"Resets all statistics (for all endpoints) on a service instance.\"\"\"\n        # Internal responses\n        self._stats = internal.create_service_stats(\n            self._id, datetime.now(timezone.utc), self._config\n        )\n        self._info = internal.create_service_info(self._id, self._config)\n        self._ping_response = internal.create_ping_info(self._id, self._config)\n        # Cache the serialized ping response\n        self._ping_response_message = dumps(asdict(self._ping_response)).encode()\n        # Reset all endpoints\n        for ep in self._endpoints:\n            ep.stats = internal.create_endpoint_stats(ep.config)\n            ep.info = internal.create_endpoint_info(ep.config)\n            self._endpoints.append(ep)\n            self._stats.endpoints.append(ep.stats)\n            self._info.endpoints.append(ep.info)\n\n    def add_group(\n        self,\n        name: str,\n        queue_group: str | None = None,\n        pending_bytes_limit_by_endpoint: int | None = None,\n        pending_msgs_limit_by_endpoint: int | None = None,\n    ) -&gt; Group:\n        \"\"\"Add a group to the service.\n\n        A group is a collection of endpoints that share the same prefix,\n        and the same default queue group and pending limits.\n\n        At runtime, a group does not exist as a separate entity, only\n        endpoints exist. However, groups are useful to organize endpoints\n        and to set default values for queue group and pending limits.\n\n        Args:\n            name: The name of the group.\n            queue_group: The default queue group of the group. When queue group is not set, it defaults to the queue group of the parent group or service.\n            pending_bytes_limit_by_endpoint: The default pending bytes limit for each endpoint within the group.\n            pending_msgs_limit_by_endpoint: The default pending messages limit for each endpoint within the group.\n        \"\"\"\n        config = internal.GroupConfig(\n            name=name,\n            queue_group=queue_group or self._config.queue_group,\n            pending_bytes_limit_by_endpoint=pending_bytes_limit_by_endpoint\n            or self._config.pending_bytes_limit_by_endpoint,\n            pending_msgs_limit_by_endpoint=pending_msgs_limit_by_endpoint\n            or self._config.pending_msgs_limit_by_endpoint,\n        )\n        return Group(config, self)\n\n    async def add_endpoint(\n        self,\n        name: str,\n        handler: Handler,\n        subject: str | None = None,\n        queue_group: str | None = None,\n        metadata: dict[str, str] | None = None,\n        pending_bytes_limit: int | None = None,\n        pending_msgs_limit: int | None = None,\n    ) -&gt; Endpoint:\n        \"\"\"Add an endpoint to the service.\n\n        An endpoint is a request-reply handler for a subject.\n\n        Args:\n            name: The name of the endpoint.\n            handler: The handler of the endpoint.\n            subject: The subject of the endpoint. When subject is not set, it defaults to the name of the endpoint.\n            queue_group: The queue group of the endpoint. When queue group is not set, it defaults to the queue group of the parent group or service.\n            metadata: The metadata of the endpoint.\n            pending_bytes_limit: The pending bytes limit for this endpoint.\n            pending_msgs_limit: The pending messages limit for this endpoint.\n        \"\"\"\n        if self._stopped:\n            raise RuntimeError(\"Cannot add endpoint to a stopped service\")\n        config = self._config.endpoint_config(\n            name=name,\n            handler=handler,\n            subject=subject,\n            queue_group=queue_group,\n            metadata=metadata,\n            pending_bytes_limit=pending_bytes_limit,\n            pending_msgs_limit=pending_msgs_limit,\n        )\n        ep = Endpoint(config)\n        subscription_handler = self._create_handler(ep)\n        subscription = (\n            await self._nc.subscribe(  # pyright: ignore[reportUnknownMemberType]\n                config.subject,\n                queue=config.queue_group,\n                cb=subscription_handler,\n            )\n        )\n        ep._sub = subscription  # pyright: ignore[reportPrivateUsage]\n        self._endpoints.append(ep)\n        self._stats.endpoints.append(ep.stats)\n        self._info.endpoints.append(ep.info)\n        return ep\n\n    async def _handle_ping_request(self, msg: Msg) -&gt; None:\n        \"\"\"Handle the ping message.\"\"\"\n        await msg.respond(data=self._ping_response_message)\n\n    async def _handle_info_request(self, msg: Msg) -&gt; None:\n        \"\"\"Handle the info message.\"\"\"\n        await msg.respond(data=dumps(asdict(self._info)).encode())\n\n    async def _handle_stats_request(self, msg: Msg) -&gt; None:\n        \"\"\"Handle the stats message.\"\"\"\n        await msg.respond(data=dumps(asdict(self._stats)).encode())\n\n    def _create_handler(self, endpoint: Endpoint) -&gt; Callable[[Msg], Awaitable[None]]:\n        \"\"\"Handle a message.\"\"\"\n\n        async def handler(msg: Msg) -&gt; None:\n            timer = internal.Timer()\n            endpoint.stats.num_requests += 1\n            request = NatsRequest(msg)\n            try:\n                await endpoint.config.handler(request)\n            except Exception as exc:\n                endpoint.stats.num_errors += 1\n                endpoint.stats.last_error = str(exc)\n                await request.respond_error(\n                    code=500,\n                    description=\"Internal Server Error\",\n                )\n            endpoint.stats.processing_time += timer.elapsed_nanoseconds()\n            endpoint.stats.average_processing_time = int(\n                endpoint.stats.processing_time / endpoint.stats.num_requests\n            )\n\n        return handler\n\n    async def __aenter__(self) -&gt; Service:\n        \"\"\"Implement the asynchronous context manager interface.\"\"\"\n        await self.start()\n        return self\n\n    async def __aexit__(self, *args: object, **kwargs: object) -&gt; None:\n        \"\"\"Implement the asynchronous context manager interface.\"\"\"\n        await self.stop()\n</code></pre>"},{"location":"reference/micro/#micro.Service.__aenter__","title":"<code>__aenter__()</code>  <code>async</code>","text":"<p>Implement the asynchronous context manager interface.</p> Source code in <code>src/micro/api.py</code> <pre><code>async def __aenter__(self) -&gt; Service:\n    \"\"\"Implement the asynchronous context manager interface.\"\"\"\n    await self.start()\n    return self\n</code></pre>"},{"location":"reference/micro/#micro.Service.__aexit__","title":"<code>__aexit__(*args, **kwargs)</code>  <code>async</code>","text":"<p>Implement the asynchronous context manager interface.</p> Source code in <code>src/micro/api.py</code> <pre><code>async def __aexit__(self, *args: object, **kwargs: object) -&gt; None:\n    \"\"\"Implement the asynchronous context manager interface.\"\"\"\n    await self.stop()\n</code></pre>"},{"location":"reference/micro/#micro.Service.add_endpoint","title":"<code>add_endpoint(name, handler, subject=None, queue_group=None, metadata=None, pending_bytes_limit=None, pending_msgs_limit=None)</code>  <code>async</code>","text":"<p>Add an endpoint to the service.</p> <p>An endpoint is a request-reply handler for a subject.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the endpoint.</p> required <code>handler</code> <code>Handler</code> <p>The handler of the endpoint.</p> required <code>subject</code> <code>str | None</code> <p>The subject of the endpoint. When subject is not set, it defaults to the name of the endpoint.</p> <code>None</code> <code>queue_group</code> <code>str | None</code> <p>The queue group of the endpoint. When queue group is not set, it defaults to the queue group of the parent group or service.</p> <code>None</code> <code>metadata</code> <code>dict[str, str] | None</code> <p>The metadata of the endpoint.</p> <code>None</code> <code>pending_bytes_limit</code> <code>int | None</code> <p>The pending bytes limit for this endpoint.</p> <code>None</code> <code>pending_msgs_limit</code> <code>int | None</code> <p>The pending messages limit for this endpoint.</p> <code>None</code> Source code in <code>src/micro/api.py</code> <pre><code>async def add_endpoint(\n    self,\n    name: str,\n    handler: Handler,\n    subject: str | None = None,\n    queue_group: str | None = None,\n    metadata: dict[str, str] | None = None,\n    pending_bytes_limit: int | None = None,\n    pending_msgs_limit: int | None = None,\n) -&gt; Endpoint:\n    \"\"\"Add an endpoint to the service.\n\n    An endpoint is a request-reply handler for a subject.\n\n    Args:\n        name: The name of the endpoint.\n        handler: The handler of the endpoint.\n        subject: The subject of the endpoint. When subject is not set, it defaults to the name of the endpoint.\n        queue_group: The queue group of the endpoint. When queue group is not set, it defaults to the queue group of the parent group or service.\n        metadata: The metadata of the endpoint.\n        pending_bytes_limit: The pending bytes limit for this endpoint.\n        pending_msgs_limit: The pending messages limit for this endpoint.\n    \"\"\"\n    if self._stopped:\n        raise RuntimeError(\"Cannot add endpoint to a stopped service\")\n    config = self._config.endpoint_config(\n        name=name,\n        handler=handler,\n        subject=subject,\n        queue_group=queue_group,\n        metadata=metadata,\n        pending_bytes_limit=pending_bytes_limit,\n        pending_msgs_limit=pending_msgs_limit,\n    )\n    ep = Endpoint(config)\n    subscription_handler = self._create_handler(ep)\n    subscription = (\n        await self._nc.subscribe(  # pyright: ignore[reportUnknownMemberType]\n            config.subject,\n            queue=config.queue_group,\n            cb=subscription_handler,\n        )\n    )\n    ep._sub = subscription  # pyright: ignore[reportPrivateUsage]\n    self._endpoints.append(ep)\n    self._stats.endpoints.append(ep.stats)\n    self._info.endpoints.append(ep.info)\n    return ep\n</code></pre>"},{"location":"reference/micro/#micro.Service.add_group","title":"<code>add_group(name, queue_group=None, pending_bytes_limit_by_endpoint=None, pending_msgs_limit_by_endpoint=None)</code>","text":"<p>Add a group to the service.</p> <p>A group is a collection of endpoints that share the same prefix, and the same default queue group and pending limits.</p> <p>At runtime, a group does not exist as a separate entity, only endpoints exist. However, groups are useful to organize endpoints and to set default values for queue group and pending limits.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the group.</p> required <code>queue_group</code> <code>str | None</code> <p>The default queue group of the group. When queue group is not set, it defaults to the queue group of the parent group or service.</p> <code>None</code> <code>pending_bytes_limit_by_endpoint</code> <code>int | None</code> <p>The default pending bytes limit for each endpoint within the group.</p> <code>None</code> <code>pending_msgs_limit_by_endpoint</code> <code>int | None</code> <p>The default pending messages limit for each endpoint within the group.</p> <code>None</code> Source code in <code>src/micro/api.py</code> <pre><code>def add_group(\n    self,\n    name: str,\n    queue_group: str | None = None,\n    pending_bytes_limit_by_endpoint: int | None = None,\n    pending_msgs_limit_by_endpoint: int | None = None,\n) -&gt; Group:\n    \"\"\"Add a group to the service.\n\n    A group is a collection of endpoints that share the same prefix,\n    and the same default queue group and pending limits.\n\n    At runtime, a group does not exist as a separate entity, only\n    endpoints exist. However, groups are useful to organize endpoints\n    and to set default values for queue group and pending limits.\n\n    Args:\n        name: The name of the group.\n        queue_group: The default queue group of the group. When queue group is not set, it defaults to the queue group of the parent group or service.\n        pending_bytes_limit_by_endpoint: The default pending bytes limit for each endpoint within the group.\n        pending_msgs_limit_by_endpoint: The default pending messages limit for each endpoint within the group.\n    \"\"\"\n    config = internal.GroupConfig(\n        name=name,\n        queue_group=queue_group or self._config.queue_group,\n        pending_bytes_limit_by_endpoint=pending_bytes_limit_by_endpoint\n        or self._config.pending_bytes_limit_by_endpoint,\n        pending_msgs_limit_by_endpoint=pending_msgs_limit_by_endpoint\n        or self._config.pending_msgs_limit_by_endpoint,\n    )\n    return Group(config, self)\n</code></pre>"},{"location":"reference/micro/#micro.Service.info","title":"<code>info()</code>","text":"<p>Returns the service info.</p> Source code in <code>src/micro/api.py</code> <pre><code>def info(self) -&gt; ServiceInfo:\n    \"\"\"Returns the service info.\"\"\"\n    return self._info.copy()\n</code></pre>"},{"location":"reference/micro/#micro.Service.reset","title":"<code>reset()</code>","text":"<p>Resets all statistics (for all endpoints) on a service instance.</p> Source code in <code>src/micro/api.py</code> <pre><code>def reset(self) -&gt; None:\n    \"\"\"Resets all statistics (for all endpoints) on a service instance.\"\"\"\n    # Internal responses\n    self._stats = internal.create_service_stats(\n        self._id, datetime.now(timezone.utc), self._config\n    )\n    self._info = internal.create_service_info(self._id, self._config)\n    self._ping_response = internal.create_ping_info(self._id, self._config)\n    # Cache the serialized ping response\n    self._ping_response_message = dumps(asdict(self._ping_response)).encode()\n    # Reset all endpoints\n    for ep in self._endpoints:\n        ep.stats = internal.create_endpoint_stats(ep.config)\n        ep.info = internal.create_endpoint_info(ep.config)\n        self._endpoints.append(ep)\n        self._stats.endpoints.append(ep.stats)\n        self._info.endpoints.append(ep.info)\n</code></pre>"},{"location":"reference/micro/#micro.Service.start","title":"<code>start()</code>  <code>async</code>","text":"<p>Start the service.</p> <p>A service MUST be started before adding endpoints.</p> <p>This will start the internal subscriptions and enable service discovery.</p> Source code in <code>src/micro/api.py</code> <pre><code>async def start(self) -&gt; None:\n    \"\"\"Start the service.\n\n    A service MUST be started before adding endpoints.\n\n    This will start the internal subscriptions and enable\n    service discovery.\n    \"\"\"\n    for subject in internal.get_internal_subjects(\n        internal.ServiceVerb.PING,\n        self._id,\n        self._config,\n        api_prefix=self._api_prefix,\n    ):\n        sub = await self._nc.subscribe(  # pyright: ignore[reportUnknownMemberType]\n            subject,\n            cb=self._handle_ping_request,\n        )\n        self._ping_subscriptions.append(sub)\n\n    for subject in internal.get_internal_subjects(\n        internal.ServiceVerb.INFO,\n        self._id,\n        self._config,\n        api_prefix=self._api_prefix,\n    ):\n        sub = await self._nc.subscribe(  # pyright: ignore[reportUnknownMemberType]\n            subject,\n            cb=self._handle_info_request,\n        )\n        self._info_subscriptions.append(sub)\n\n    for subject in internal.get_internal_subjects(\n        internal.ServiceVerb.STATS,\n        self._id,\n        self._config,\n        api_prefix=self._api_prefix,\n    ):\n        sub = await self._nc.subscribe(  # pyright: ignore[reportUnknownMemberType]\n            subject,\n            cb=self._handle_stats_request,\n        )\n        self._stats_subscriptions.append(sub)\n</code></pre>"},{"location":"reference/micro/#micro.Service.stats","title":"<code>stats()</code>","text":"<p>Returns statistics for the service endpoint and all monitoring endpoints.</p> Source code in <code>src/micro/api.py</code> <pre><code>def stats(self) -&gt; ServiceStats:\n    \"\"\"Returns statistics for the service endpoint and all monitoring endpoints.\"\"\"\n    return self._stats.copy()\n</code></pre>"},{"location":"reference/micro/#micro.Service.stop","title":"<code>stop()</code>  <code>async</code>","text":"<p>Stop the service.</p> <p>This will stop all endpoints and internal subscriptions.</p> Source code in <code>src/micro/api.py</code> <pre><code>async def stop(self) -&gt; None:\n    \"\"\"Stop the service.\n\n    This will stop all endpoints and internal subscriptions.\n    \"\"\"\n    self._stopped = True\n    # Stop endpoints\n    await asyncio.gather(*(ep.stop() for ep in self._endpoints))\n    # Stop internal subscriptions\n    await asyncio.gather(\n        *(\n            sub.unsubscribe()\n            for subscriptions in (\n                self._stats_subscriptions,\n                self._info_subscriptions,\n                self._ping_subscriptions,\n            )\n            for sub in subscriptions\n        )\n    )\n</code></pre>"},{"location":"reference/micro/#micro.Service.stopped","title":"<code>stopped()</code>","text":"<p>Stopped informs whether [Stop] was executed on the service.</p> Source code in <code>src/micro/api.py</code> <pre><code>def stopped(self) -&gt; bool:\n    \"\"\"Stopped informs whether [Stop] was executed on the service.\"\"\"\n    return self._stopped\n</code></pre>"},{"location":"reference/micro/#micro.ServiceInfo","title":"<code>ServiceInfo</code>  <code>dataclass</code>","text":"<p>The information of a service.</p> Source code in <code>src/micro/models.py</code> <pre><code>@dataclass\nclass ServiceInfo:\n    \"\"\"The information of a service.\"\"\"\n\n    name: str\n    id: str\n    version: str\n    description: str\n    metadata: dict[str, str]\n    endpoints: list[EndpointInfo]\n    data: dict[str, object]\n    type: str = \"io.nats.micro.v1.info_response\"\n\n    def copy(self) -&gt; ServiceInfo:\n        return replace(\n            self,\n            endpoints=[ep.copy() for ep in self.endpoints],\n            metadata=self.metadata.copy(),\n            data=self.data.copy(),\n        )\n</code></pre>"},{"location":"reference/micro/#micro.ServiceStats","title":"<code>ServiceStats</code>  <code>dataclass</code>","text":"<p>The statistics of a service.</p> Source code in <code>src/micro/models.py</code> <pre><code>@dataclass\nclass ServiceStats:\n    \"\"\"The statistics of a service.\"\"\"\n\n    name: str\n    id: str\n    version: str\n    started: str\n    endpoints: list[EndpointStats]\n    metadata: dict[str, str]\n    type: str = \"io.nats.micro.v1.stats_response\"\n\n    def copy(self) -&gt; ServiceStats:\n        return replace(\n            self,\n            endpoints=[ep.copy() for ep in self.endpoints],\n            metadata=self.metadata.copy(),\n        )\n</code></pre>"},{"location":"reference/micro/#micro.add_service","title":"<code>add_service(nc, name, version, description=None, metadata=None, queue_group=None, api_prefix=None)</code>","text":"<p>Create a new service.</p> <p>A service is a collection of endpoints that are grouped together under a common name.</p> <p>Each endpoint is a request-reply handler for a subject.</p> <p>It's possible to add endpoints to a service after it has been created AND started.</p> <p>Parameters:</p> Name Type Description Default <code>nc</code> <code>Client</code> <p>The NATS client.</p> required <code>name</code> <code>str</code> <p>The name of the service.</p> required <code>version</code> <code>str</code> <p>The version of the service. Must be a valid semver version.</p> required <code>description</code> <code>str | None</code> <p>The description of the service.</p> <code>None</code> <code>metadata</code> <code>dict[str, str] | None</code> <p>The metadata of the service.</p> <code>None</code> <code>api_prefix</code> <code>str | None</code> <p>The prefix of the control subjects.</p> <code>None</code> Source code in <code>src/micro/api.py</code> <pre><code>def add_service(\n    nc: NatsClient,\n    name: str,\n    version: str,\n    description: str | None = None,\n    metadata: dict[str, str] | None = None,\n    queue_group: str | None = None,\n    api_prefix: str | None = None,\n) -&gt; Service:\n    \"\"\"Create a new service.\n\n    A service is a collection of endpoints that are grouped together\n    under a common name.\n\n    Each endpoint is a request-reply handler for a subject.\n\n    It's possible to add endpoints to a service after it has been created AND\n    started.\n\n    Args:\n        nc: The NATS client.\n        name: The name of the service.\n        version: The version of the service. Must be a valid semver version.\n        description: The description of the service.\n        metadata: The metadata of the service.\n        api_prefix: The prefix of the control subjects.\n    \"\"\"\n\n    config = internal.ServiceConfig(\n        name=name,\n        version=version,\n        description=description or \"\",\n        metadata=metadata or {},\n        queue_group=queue_group or DEFAULT_QUEUE_GROUP,\n        pending_bytes_limit_by_endpoint=DEFAULT_SUB_PENDING_BYTES_LIMIT,\n        pending_msgs_limit_by_endpoint=DEFAULT_SUB_PENDING_MSGS_LIMIT,\n    )\n    srv = Service(nc=nc, config=config, api_prefix=api_prefix or API_PREFIX)\n    return srv\n</code></pre>"}]}